<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The `wasm-bindgen` Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li><a href="whirlwind-tour/introduction.html"><strong aria-hidden="true">1.</strong> Whirlwind Tour</a></li><li><ol class="section"><li><a href="whirlwind-tour/basic-usage.html"><strong aria-hidden="true">1.1.</strong> Basic Usage</a></li><li><a href="whirlwind-tour/what-just-happened.html"><strong aria-hidden="true">1.2.</strong> What Just Happened?</a></li><li><a href="whirlwind-tour/what-else-can-we-do.html"><strong aria-hidden="true">1.3.</strong> What Else Can We Do?</a></li></ol></li><li><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li><a href="examples/hello-world.html"><strong aria-hidden="true">2.1.</strong> Hello, World!</a></li><li><a href="examples/console-log.html"><strong aria-hidden="true">2.2.</strong> Using console.log</a></li><li><a href="examples/add.html"><strong aria-hidden="true">2.3.</strong> Small wasm files</a></li><li><a href="examples/no-modules.html"><strong aria-hidden="true">2.4.</strong> Using --no-modules</a></li><li><a href="examples/wasm2js.html"><strong aria-hidden="true">2.5.</strong> Converting WebAssembly to JS</a></li><li><a href="examples/import-js.html"><strong aria-hidden="true">2.6.</strong> Importing functions from JS</a></li><li><a href="examples/char.html"><strong aria-hidden="true">2.7.</strong> Working with char</a></li><li><a href="examples/wasm-in-wasm.html"><strong aria-hidden="true">2.8.</strong> js-sys: WebAssembly in WebAssembly</a></li><li><a href="examples/dom.html"><strong aria-hidden="true">2.9.</strong> web-sys: DOM hello world</a></li><li><a href="examples/closures.html"><strong aria-hidden="true">2.10.</strong> web-sys: Closures</a></li><li><a href="examples/performance.html"><strong aria-hidden="true">2.11.</strong> web-sys: performance.now</a></li><li><a href="examples/fetch.html"><strong aria-hidden="true">2.12.</strong> web-sys: using fetch</a></li><li><a href="examples/2d-canvas.html"><strong aria-hidden="true">2.13.</strong> web-sys: canvas hello world</a></li><li><a href="examples/julia.html"><strong aria-hidden="true">2.14.</strong> web-sys: canvas Julia set</a></li><li><a href="examples/web-audio.html"><strong aria-hidden="true">2.15.</strong> web-sys: WebAudio</a></li><li><a href="examples/webgl.html"><strong aria-hidden="true">2.16.</strong> web-sys: WebGL</a></li><li><a href="examples/paint.html"><strong aria-hidden="true">2.17.</strong> web-sys: A Simple Paint Program</a></li></ol></li><li><a href="reference/index.html"><strong aria-hidden="true">3.</strong> Reference</a></li><li><ol class="section"><li><a href="reference/passing-rust-closures-to-js.html"><strong aria-hidden="true">3.1.</strong> Passing Rust Closures to JS</a></li><li><a href="reference/receiving-js-closures-in-rust.html"><strong aria-hidden="true">3.2.</strong> Receiving JS Closures in Rust</a></li><li><a href="reference/js-promises-and-rust-futures.html"><strong aria-hidden="true">3.3.</strong> Promises and Futures</a></li><li><a href="reference/iterating-over-js-values.html"><strong aria-hidden="true">3.4.</strong> Iterating over JS Values</a></li><li><a href="reference/no-esm.html"><strong aria-hidden="true">3.5.</strong> No ES Modules</a></li><li><a href="reference/arbitrary-data-with-serde.html"><strong aria-hidden="true">3.6.</strong> Arbitrary Data with Serde</a></li><li><a href="reference/accessing-properties-of-untyped-js-values.html"><strong aria-hidden="true">3.7.</strong> Accessing Properties of Untyped JS Values</a></li><li><a href="reference/working-with-duck-typed-interfaces.html"><strong aria-hidden="true">3.8.</strong> Working with Duck-Typed Interfaces</a></li><li><a href="reference/cli.html"><strong aria-hidden="true">3.9.</strong> Command Line Interface</a></li><li><a href="reference/optimize-size.html"><strong aria-hidden="true">3.10.</strong> Optimizing for Size</a></li><li><a href="reference/types.html"><strong aria-hidden="true">3.11.</strong> Supported Types</a></li><li><ol class="section"><li><a href="reference/types/imported-js-types.html"><strong aria-hidden="true">3.11.1.</strong> Imported JavaScript Types</a></li><li><a href="reference/types/exported-rust-types.html"><strong aria-hidden="true">3.11.2.</strong> Exported Rust Types</a></li><li><a href="reference/types/jsvalue.html"><strong aria-hidden="true">3.11.3.</strong> JsValue</a></li><li><a href="reference/types/boxed-jsvalue-slice.html"><strong aria-hidden="true">3.11.4.</strong> Box&lt;[JsValue]&gt;</a></li><li><a href="reference/types/pointers.html"><strong aria-hidden="true">3.11.5.</strong> *const T and *mut T</a></li><li><a href="reference/types/numbers.html"><strong aria-hidden="true">3.11.6.</strong> Numbers</a></li><li><a href="reference/types/bool.html"><strong aria-hidden="true">3.11.7.</strong> bool</a></li><li><a href="reference/types/char.html"><strong aria-hidden="true">3.11.8.</strong> char</a></li><li><a href="reference/types/str.html"><strong aria-hidden="true">3.11.9.</strong> str</a></li><li><a href="reference/types/string.html"><strong aria-hidden="true">3.11.10.</strong> String</a></li><li><a href="reference/types/number-slices.html"><strong aria-hidden="true">3.11.11.</strong> Number Slices</a></li><li><a href="reference/types/boxed-number-slices.html"><strong aria-hidden="true">3.11.12.</strong> Boxed Number Slices</a></li><li><a href="reference/types/result.html"><strong aria-hidden="true">3.11.13.</strong> Result&lt;T, JsValue&gt;</a></li></ol></li><li><a href="reference/attributes/index.html"><strong aria-hidden="true">3.12.</strong> #[wasm_bindgen] Attributes</a></li><li><ol class="section"><li><a href="reference/attributes/on-js-imports/index.html"><strong aria-hidden="true">3.12.1.</strong> On JavaScript Imports</a></li><li><ol class="section"><li><a href="reference/attributes/on-js-imports/catch.html"><strong aria-hidden="true">3.12.1.1.</strong> catch</a></li><li><a href="reference/attributes/on-js-imports/constructor.html"><strong aria-hidden="true">3.12.1.2.</strong> constructor</a></li><li><a href="reference/attributes/on-js-imports/extends.html"><strong aria-hidden="true">3.12.1.3.</strong> extends</a></li><li><a href="reference/attributes/on-js-imports/getter-and-setter.html"><strong aria-hidden="true">3.12.1.4.</strong> getter and setter</a></li><li><a href="reference/attributes/on-js-imports/indexing-getter-setter-deleter.html"><strong aria-hidden="true">3.12.1.5.</strong> indexing_getter, indexing_setter, and indexing_deleter</a></li><li><a href="reference/attributes/on-js-imports/js_class.html"><strong aria-hidden="true">3.12.1.6.</strong> js_class = &quot;Blah&quot;</a></li><li><a href="reference/attributes/on-js-imports/js_name.html"><strong aria-hidden="true">3.12.1.7.</strong> js_name</a></li><li><a href="reference/attributes/on-js-imports/js_namespace.html"><strong aria-hidden="true">3.12.1.8.</strong> js_namespace</a></li><li><a href="reference/attributes/on-js-imports/method.html"><strong aria-hidden="true">3.12.1.9.</strong> method</a></li><li><a href="reference/attributes/on-js-imports/module.html"><strong aria-hidden="true">3.12.1.10.</strong> module = &quot;blah&quot;</a></li><li><a href="reference/attributes/on-js-imports/static_method_of.html"><strong aria-hidden="true">3.12.1.11.</strong> static_method_of = Blah</a></li><li><a href="reference/attributes/on-js-imports/structural.html"><strong aria-hidden="true">3.12.1.12.</strong> structural</a></li><li><a href="reference/attributes/on-js-imports/variadic.html"><strong aria-hidden="true">3.12.1.13.</strong> variadic</a></li></ol></li><li><a href="reference/attributes/on-rust-exports/index.html"><strong aria-hidden="true">3.12.2.</strong> On Rust Exports</a></li><li><ol class="section"><li><a href="reference/attributes/on-rust-exports/constructor.html"><strong aria-hidden="true">3.12.2.1.</strong> constructor</a></li><li><a href="reference/attributes/on-rust-exports/js_name.html"><strong aria-hidden="true">3.12.2.2.</strong> js_name = Blah</a></li><li><a href="reference/attributes/on-rust-exports/readonly.html"><strong aria-hidden="true">3.12.2.3.</strong> readonly</a></li><li class="spacer"></li></ol></li></ol></li></ol></li><li><a href="web-sys/index.html"><strong aria-hidden="true">5.</strong> web-sys</a></li><li><ol class="section"><li><a href="web-sys/using-web-sys.html"><strong aria-hidden="true">5.1.</strong> Using web-sys</a></li><li><a href="web-sys/cargo-features.html"><strong aria-hidden="true">5.2.</strong> Cargo Features</a></li><li><a href="web-sys/function-overloads.html"><strong aria-hidden="true">5.3.</strong> Function Overloads</a></li><li><a href="web-sys/type-translations.html"><strong aria-hidden="true">5.4.</strong> Type Translations</a></li><li class="spacer"></li></ol></li><li><a href="wasm-bindgen-test/index.html"><strong aria-hidden="true">7.</strong> Testing with wasm-bindgen-test</a></li><li><ol class="section"><li><a href="wasm-bindgen-test/usage.html"><strong aria-hidden="true">7.1.</strong> Usage</a></li><li><a href="wasm-bindgen-test/asynchronous-tests.html"><strong aria-hidden="true">7.2.</strong> Writing Asynchronous Tests</a></li><li><a href="wasm-bindgen-test/browsers.html"><strong aria-hidden="true">7.3.</strong> Testing in Headless Browsers</a></li><li><a href="wasm-bindgen-test/continuous-integration.html"><strong aria-hidden="true">7.4.</strong> Continuous Integration</a></li><li class="spacer"></li></ol></li><li><a href="contributing/index.html"><strong aria-hidden="true">9.</strong> Contributing to wasm-bindgen</a></li><li><ol class="section"><li><a href="contributing/testing.html"><strong aria-hidden="true">9.1.</strong> Testing</a></li><li><a href="contributing/design/index.html"><strong aria-hidden="true">9.2.</strong> Internal Design</a></li><li><ol class="section"><li><a href="contributing/design/js-objects-in-rust.html"><strong aria-hidden="true">9.2.1.</strong> JS Objects in Rust</a></li><li><a href="contributing/design/exporting-rust.html"><strong aria-hidden="true">9.2.2.</strong> Exporting a function to JS</a></li><li><a href="contributing/design/exporting-rust-struct.html"><strong aria-hidden="true">9.2.3.</strong> Exporting a struct to JS</a></li><li><a href="contributing/design/importing-js.html"><strong aria-hidden="true">9.2.4.</strong> Importing a function from JS</a></li><li><a href="contributing/design/importing-js-struct.html"><strong aria-hidden="true">9.2.5.</strong> Importing a class from JS</a></li><li><a href="contributing/design/rust-type-conversions.html"><strong aria-hidden="true">9.2.6.</strong> Rust Type conversions</a></li><li><a href="contributing/design/describe.html"><strong aria-hidden="true">9.2.7.</strong> Types in wasm-bindgen</a></li></ol></li><li><a href="contributing/js-sys/index.html"><strong aria-hidden="true">9.3.</strong> js-sys</a></li><li><ol class="section"><li><a href="contributing/js-sys/testing.html"><strong aria-hidden="true">9.3.1.</strong> Testing</a></li><li><a href="contributing/js-sys/adding-more-apis.html"><strong aria-hidden="true">9.3.2.</strong> Adding More APIs</a></li></ol></li><li><a href="contributing/web-sys/index.html"><strong aria-hidden="true">9.4.</strong> web-sys</a></li><li><ol class="section"><li><a href="contributing/web-sys/overview.html"><strong aria-hidden="true">9.4.1.</strong> Overview</a></li><li><a href="contributing/web-sys/testing.html"><strong aria-hidden="true">9.4.2.</strong> Testing</a></li><li><a href="contributing/web-sys/logging.html"><strong aria-hidden="true">9.4.3.</strong> Logging</a></li><li><a href="contributing/web-sys/supporting-more-web-apis.html"><strong aria-hidden="true">9.4.4.</strong> Supporting More Web APIs</a></li></ol></li><li><a href="contributing/publishing.html"><strong aria-hidden="true">9.5.</strong> Publishing</a></li><li><a href="contributing/team.html"><strong aria-hidden="true">9.6.</strong> Team</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The `wasm-bindgen` Guide</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p><code>wasm-bindgen</code> facilitates high-level interactions between wasm modules and
JavaScript.</p>
<p>This project is sort of half polyfill for features like the <a href="https://github.com/WebAssembly/host-bindings">host bindings
proposal</a> and half features for empowering high-level interactions between
JS and wasm-compiled code (currently mostly from Rust). More specifically this
project allows JS/wasm to communicate with strings, JS objects, classes, etc, as
opposed to purely integers and floats. Using <code>wasm-bindgen</code> for example you can
define a JS class in Rust or take a string from JS or return one. The
functionality is growing as well!</p>
<p>Currently this tool is Rust-focused but the underlying foundation is
language-independent, and it's hoping that over time as this tool stabilizes
that it can be used for languages like C/C++!</p>
<p>Notable features of this project includes:</p>
<ul>
<li>Importing JS functionality in to Rust such as <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/dom">DOM manipulation</a>,
<a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/console_log">console logging</a>, or <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/performance">performance monitoring</a>.</li>
<li>Exporting Rust functionality to JS such as classes, functions, etc.</li>
<li>Working with rich types like strings, numbers, classes, closures, and objects
rather than simply <code>u32</code> and floats.</li>
</ul>
<p>This project is still relatively new but feedback is of course always
welcome! If you're curious about the design plus even more information about
what this crate can do, check out the <a href="https://rustwasm.github.io/wasm-bindgen/contributing/design/index.html">design doc</a>.</p>
<a class="header" href="#a-whirlwind-tour-of-wasm-bindgen" id="a-whirlwind-tour-of-wasm-bindgen"><h1>A Whirlwind Tour of <code>wasm-bindgen</code></h1></a>
<p>What follows is a whirlwind tour of <code>wasm-bindgen</code>.</p>
<p>You will learn:</p>
<ul>
<li>Setting up your development environment for <code>wasm-bindgen</code></li>
<li>Importing JavaScript functions and classes into Rust</li>
<li>Exporting Rust structs and functions to JavaScript</li>
</ul>
<a class="header" href="#basic-usage" id="basic-usage"><h1>Basic Usage</h1></a>
<p>Let's implement the equivalent of &quot;Hello, world!&quot; for this crate.</p>
<blockquote>
<p><strong>Note:</strong> Currently this projects uses <em>nightly Rust</em> which you can acquire
through <a href="https://rustup.rs">rustup</a> and configure with <code>rustup default nightly</code></p>
</blockquote>
<p>If you'd like you can dive <a href="https://webassembly.studio/?f=gzubao6tg3">straight into an online example</a>, but
if you'd prefer to follow along in your own console let's install the tools we
need:</p>
<pre><code class="language-shell">$ rustup target add wasm32-unknown-unknown
$ cargo +nightly install wasm-bindgen-cli
</code></pre>
<p>The first command here installs the wasm target so you can compile to it, and
the latter will install the <code>wasm-bindgen</code> CLI tool we'll be using later.</p>
<p>Next up let's make our project</p>
<pre><code class="language-shell">$ cargo +nightly new js-hello-world --lib
</code></pre>
<p>Now let's add a dependency on this project inside <code>Cargo.toml</code> as well as
configuring our build output:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = &quot;0.2&quot;
</code></pre>
<p>Next up our actual code! We'll write this in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
</code></pre>
<p>And that's it! If we were to write the <code>greet</code> function naively without the
<code>#[wasm_bindgen]</code> attribute then JS wouldn't be able to communicate with the
types like <code>str</code>, so slapping a <code>#[wasm_bindgen]</code> on the function and the import
of <code>alert</code> ensures that the right shims are generated.</p>
<p>Next up let's build our project:</p>
<pre><code class="language-shell">$ cargo +nightly build --target wasm32-unknown-unknown
</code></pre>
<p>After this you'll have a wasm file at
<code>target/wasm32-unknown-unknown/debug/js_hello_world.wasm</code>. Don't be alarmed at
the size, this is an unoptimized program!</p>
<p>Now that we've generated the wasm module it's time to run the bindgen tool
itself! This tool will postprocess the wasm file rustc generated, generating a
new wasm file and a set of JS bindings as well. Let's invoke it!</p>
<pre><code class="language-shell">$ wasm-bindgen target/wasm32-unknown-unknown/debug/js_hello_world.wasm \
  --out-dir .
</code></pre>
<p>This is the main point where the magic happens. The <code>js_hello_world.wasm</code> file
emitted by rustc contains <em>descriptors</em> of how to communicate via richer types
than wasm currently supports. The <code>wasm-bindgen</code> tool will interpret this
information, emitting a <strong>replacement module</strong> for the wasm file.</p>
<p>The previous <code>js_hello_world.wasm</code> file is interpreted as if it were an ES6
module. The <code>js_hello_world.js</code> file emitted by <code>wasm-bindgen</code> should have the
intended interface of the wasm file, notably with rich types like strings,
classes, etc.</p>
<p>The <code>wasm-bindgen</code> tool also emits a few other files needed to implement this
module. For example <code>js_hello_world_bg.wasm</code> is the original wasm file but
postprocessed a bit. It's intended that the <code>js_hello_world_bg.wasm</code> file,
like before, acts like an ES6 module.</p>
<p>At this point you'll probably plug these files into a larger build system.
Files emitted by <code>wasm-bindgen</code> act like normal ES6 modules (one just happens to
be wasm). As of the time of this writing there's unfortunately not a lot of
tools that natively do this, but Webpack's 4.0 beta release has native wasm
support! Let's take a look at that and see how it works.</p>
<p>First, create an <code>index.js</code> file:</p>
<pre><code class="language-js">const js = import(&quot;./js_hello_world&quot;);

js.then(js =&gt; {
  js.greet(&quot;World!&quot;);
});
</code></pre>
<p>Note that we're using <code>import(..)</code> here because Webpack <a href="https://github.com/webpack/webpack/issues/6615">doesn't
support</a> synchronously importing modules from the main chunk just
yet.</p>
<p>Next, define our JS dependencies by creating a <code>package.json</code>:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;webpack&quot;: &quot;^4.0.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.1&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.0&quot;
  }
}
</code></pre>
<p>and our <code>webpack</code> configuration:</p>
<pre><code class="language-js">// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: &quot;./index.js&quot;,
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;index.js&quot;,
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: &quot;Getting started with WASM&quot;
    })
  ],
  mode: &quot;development&quot;
};
</code></pre>
<p>And finally:</p>
<pre><code class="language-shell">$ npm install
$ npm run serve
</code></pre>
<p>If you open <a href="http://localhost:8080">http://localhost:8080</a> in a browser you should see a <code>Hello, world!</code>
dialog pop up!</p>
<p>Notice that <code>html-webpack-plugin</code> has generated an HTML page which includes <code>index.js</code>.</p>
<p>Finally, you may want to deploy your application to a web server like Apache or NGINX.
For that, simply run:</p>
<pre><code class="language-shell">$ npx webpack
</code></pre>
<p>The output will be in the <code>dist</code> directory. You can now copy it to the root of your
web server.</p>
<p>If that was all a bit much, no worries! You can <a href="https://webassembly.studio/?f=gzubao6tg3">execute this code
online</a> thanks to <a href="https://webassembly.studio">WebAssembly Studio</a>
or you can <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/hello_world">follow along on GitHub</a> to see all the files necessary
as well as a script to set it all up.</p>
<a class="header" href="#what-just-happened" id="what-just-happened"><h1>What Just Happened?</h1></a>
<p>Phew! That was a lot of words and a lot ended up happening along the way. There
were two main pieces of magic happening: the <code>#[wasm_bindgen]</code> attribute and the
<code>wasm-bindgen</code> CLI tool.</p>
<p><strong>The <code>#[wasm_bindgen]</code> attribute</strong></p>
<p>This attribute, exported from the <code>wasm-bindgen</code> crate, is the entrypoint to
exposing Rust functions to JS. This is a procedural macro (hence requiring the
nightly Rust toolchain) which will generate the appropriate shims in Rust to
translate from your type signature to one that JS can interface with. Finally
the attribute also serializes some information to the output artifact which
<code>wasm-bindgen</code>-the-tool will discard after it parses.</p>
<p>There's a more thorough explanation below of the various bits and pieces of the
attribute, but it suffices for now to say that you can attach it to free
functions, structs, impl blocks for those structs and <code>extern { ... }</code> blocks.
Some Rust features like generics, lifetime parameters, etc, aren't supported on
functions tagged with <code>#[wasm_bindgen]</code> right now.</p>
<p><strong>The <code>wasm-bindgen</code> CLI tool</strong></p>
<p>The next half of what happened here was all in the <code>wasm-bindgen</code> tool. This
tool opened up the wasm module that rustc generated and found an encoded
description of what was passed to the <code>#[wasm_bindgen]</code> attribute. You can
think of this as the <code>#[wasm_bindgen]</code> attribute created a special section of
the output module which <code>wasm-bindgen</code> strips and processes.</p>
<p>This information gave <code>wasm-bindgen</code> all it needed to know to generate the JS
file that we then imported. The JS file wraps instantiating the underlying wasm
module (aka calling <code>WebAssembly.instantiate</code>) and then provides wrappers for
classes/functions within.</p>
<a class="header" href="#what-else-can-we-do" id="what-else-can-we-do"><h1>What Else Can We Do?</h1></a>
<p>Much more! Here's a taste of various features you can use in this project. You
can also <a href="https://webassembly.studio/?f=t61j18noqz">explore this code online</a>:</p>
<pre><code class="language-rust ignore">// src/lib.rs
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

// Strings can both be passed in and received
#[wasm_bindgen]
pub fn concat(a: &amp;str, b: &amp;str) -&gt; String {
    let mut a = a.to_string();
    a.push_str(b);
    return a
}

// A struct will show up as a class on the JS side of things
#[wasm_bindgen]
pub struct Foo {
    contents: u32,
}

#[wasm_bindgen]
impl Foo {
    #[wasm_bindgen(constructor)]
    pub fn new() -&gt; Foo {
        Foo { contents: 0 }
    }

    // Methods can be defined with `&amp;mut self` or `&amp;self`, and arguments you
    // can pass to a normal free function also all work in methods.
    pub fn add(&amp;mut self, amt: u32) -&gt; u32 {
        self.contents += amt;
        return self.contents
    }

    // You can also take a limited set of references to other types as well.
    pub fn add_other(&amp;mut self, bar: &amp;Bar) {
        self.contents += bar.contents;
    }

    // Ownership can work too!
    pub fn consume_other(&amp;mut self, bar: Bar) {
        self.contents += bar.contents;
    }
}

#[wasm_bindgen]
pub struct Bar {
    contents: u32,
    opaque: JsValue, // defined in `wasm_bindgen`, imported via prelude
}

#[wasm_bindgen(module = &quot;./index&quot;)] // what ES6 module to import from
extern {
    fn bar_on_reset(to: &amp;str, opaque: &amp;JsValue);

    // We can import classes and annotate functionality on those classes as well
    type Awesome;
    #[wasm_bindgen(constructor)]
    fn new() -&gt; Awesome;
    #[wasm_bindgen(method)]
    fn get_internal(this: &amp;Awesome) -&gt; u32;
    // We can call javascript functions that have a dynamic number of arguments,
    // e.g. rust `sum(&amp;[1, 2, 3])` will be called like `sum(1, 2, 3)`
    #[wasm_bindgen(variadic)]
    fn sum(vals: &amp;[u32]) -&gt; u32;
}

#[wasm_bindgen]
impl Bar {
    pub fn from_str(s: &amp;str, opaque: JsValue) -&gt; Bar {
        let contents = s.parse().unwrap_or_else(|_| {
            Awesome::new().get_internal()
        });
        Bar { contents, opaque }
    }

    pub fn reset(&amp;mut self, s: &amp;str) {
        if let Ok(n) = s.parse() {
            bar_on_reset(s, &amp;self.opaque);
            self.contents = n;
        }
    }
}
</code></pre>
<p>The generated JS bindings for this invocation of the macro <a href="https://gist.github.com/alexcrichton/3d85c505e785fb8ff32e2c1cf9618367">look like
this</a>. You can view them in action like so:</p>
<p>and our corresponding <code>index.js</code>:</p>
<pre><code class="language-js">import { Foo, Bar, concat } from &quot;./js_hello_world&quot;;
import { booted } from &quot;./js_hello_world_wasm&quot;;

export function bar_on_reset(s, token) {
  console.log(token);
  console.log(`this instance of bar was reset to ${s}`);
}

function assertEq(a, b) {
  if (a !== b)
    throw new Error(`${a} != ${b}`);
  console.log(`found ${a} === ${b}`);
}

function main() {
  assertEq(concat('a', 'b'), 'ab');

  // Note that to use `new Foo()` the constructor function must be annotated
  // with `#[wasm_bindgen(constructor)]`, otherwise only `Foo.new()` can be used.
  // Additionally objects allocated corresponding to Rust structs will need to
  // be deallocated on the Rust side of things with an explicit call to `free`.
  let foo = new Foo();
  assertEq(foo.add(10), 10);
  foo.free();

  // Pass objects to one another
  let foo1 = new Foo();
  let bar = Bar.from_str(&quot;22&quot;, { opaque: 'object' });
  foo1.add_other(bar);

  // We also don't have to `free` the `bar` variable as this function is
  // transferring ownership to `foo1`
  bar.reset('34');
  foo1.consume_other(bar);

  assertEq(foo1.add(2), 22 + 34 + 2);
  foo1.free();

  alert('all passed!')
}

export class Awesome {
  constructor() {
    this.internal = 32;
  }

  get_internal() {
    return this.internal;
  }
}

export function sum(...args) {
    let answer = 0;
    for(var i=0; i&lt;args.length; i++) {
        answer += args[i];
    }
    return answer;
}

booted.then(main);
</code></pre>
<a class="header" href="#examples-of-using-wasm-bindgen-js-sys-and-web-sys" id="examples-of-using-wasm-bindgen-js-sys-and-web-sys"><h1>Examples of using <code>wasm-bindgen</code>, <code>js-sys</code>, and <code>web-sys</code></h1></a>
<p>This subsection contains examples of using the <code>wasm-bindgen</code>, <code>js-sys</code>, and
<code>web-sys</code> crates. Each example should have more information about what it's
doing.</p>
<p>The source code for all examples can also be <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples">found online</a> to download an
run locally. Each example is accompanied with a <code>build.sh</code> script to outline the
steps necessary to build and run it as well.</p>
<p>Note that most examples currently use Webpack to assemble the final output
artifact, but this is not required! You can use the bundler of choice,
<code>--no-modules</code>, or native browser ESM support as alternatives to Webpack.</p>
<a class="header" href="#hello-world" id="hello-world"><h1>Hello, World!</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/hello_world">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/hello_world/">view the compiled example online</a></p>
<p>This is the &quot;Hello, world!&quot; example of <code>#[wasm_bindgen]</code> showing how to set up
a project, export a function to JS, call it from JS, and then call the <code>alert</code>
function in Rust.</p>
<a class="header" href="#cargotoml" id="cargotoml"><h2><code>Cargo.toml</code></h2></a>
<p>The <code>Cargo.toml</code> enables depends on the <code>wasm-bindgen</code> crate. Here we're using
a <code>path</code> dependency because this example lives in the <code>wasm-bindgen</code> repository
itself, but you'd use the commented out version beneath it instead.</p>
<p>Also of note is the <code>crate-type = [&quot;cdylib&quot;]</code> which is largely used for wasm
final artifacts today.</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
# Here we're using a path dependency to use what's already in this repository,
# but you'd use the commented out version below if you're copying this into your
# project.
wasm-bindgen = { path = &quot;../..&quot; }
#wasm-bindgen = &quot;0.2&quot;

</code></pre>
<a class="header" href="#srclibrs" id="srclibrs"><h2><code>src/lib.rs</code></h2></a>
<p>Here we define our Rust entry point along with calling the <code>alert</code> function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern &quot;C&quot; {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}

#}</code></pre></pre>
<a class="header" href="#indexjs" id="indexjs"><h2><code>index.js</code></h2></a>
<p>Our JS entry point is quite small!</p>
<pre><code class="language-js">// Note that a dynamic `import` statement here is required due to
// webpack/webpack#6615, but in theory `import { greet } from './hello_world';`
// will work here one day as well!
const rust = import('./hello_world');

rust.then(m =&gt; m.greet('World!'));

</code></pre>
<a class="header" href="#webpack-specific-files" id="webpack-specific-files"><h2>Webpack-specific files</h2></a>
<p>And finally here's the Webpack configuration and <code>package.json</code> for this
project:</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="language-js">const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    entry: './index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'index.js',
    },
    plugins: [
        new HtmlWebpackPlugin()
    ],
    mode: 'development'
};

</code></pre>
<p><strong>package.json</strong></p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;webpack&quot;: &quot;^4.11.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.1&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.0&quot;
  }
}

</code></pre>
<a class="header" href="#consolelog" id="consolelog"><h1><code>console.log</code></h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/console_log">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/console_log/">view the compiled example online</a></p>
<p>This example shows off how to use <code>console.log</code> in a variety of ways, all the
way from bare-bones usage to a <code>println!</code>-like macro with <code>web_sys</code>.</p>
<a class="header" href="#srclibrs-1" id="srclibrs-1"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;
extern crate web_sys;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn run() {
    bare_bones();
    using_a_macro();
    using_web_sys();
}

// First up let's take a look of binding `console.log` manually, without the
// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations
// manually ourselves, and the correctness of our program relies on the
// correctness of these annotations!

#[wasm_bindgen]
extern &quot;C&quot; {
    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);

    // The `console.log` is quite polymorphic, so we can bind it with multiple
    // signatures. Note that we need to use `js_name` to ensure we always call
    // `log` in JS.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // Multiple arguments too!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &amp;str, b: &amp;str);
}

fn bare_bones() {
    log(&quot;Hello from Rust!&quot;);
    log_u32(42);
    log_many(&quot;Logging&quot;, &quot;many values!&quot;);
}

// Next let's define a macro that's like `println!`, only it works for
// `console.log`. Note that `println!` doesn't actually work on the wasm target
// because the standard library currently just eats all output. To get
// `println!`-like behavior in your app you'll likely want a macro like this.

macro_rules! console_log {
    // Note that this is using the `log` function imported above during
    // `bare_bones`
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

fn using_a_macro() {
    console_log!(&quot;Hello {}!&quot;, &quot;world&quot;);
    console_log!(&quot;Let's print some numbers...&quot;);
    console_log!(&quot;1 + 3 = {}&quot;, 1 + 3);
}

// And finally, we don't even have to define the `log` function ourselves! The
// `web_sys` crate already has it defined for us.

fn using_web_sys() {
    use web_sys::console;

    console::log_1(&amp;&quot;Hello using web-sys&quot;.into());

    let js: JsValue = 4.into();
    console::log_2(&amp;&quot;Logging arbitrary values looks like&quot;.into(), &amp;js);
}

#}</code></pre></pre>
<a class="header" href="#small-wasm-files" id="small-wasm-files"><h1>Small wasm files</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/add">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/add/">view the compiled example online</a></p>
<p>One of <code>wasm-bindgen</code>'s core goals is a pay-only-for-what-you-use philosophy, so
if we don't use much then we shouldn't be paying much! As a result
<code>#[wasm_bindgen]</code> can generate super-small executables</p>
<p>Currently this code...</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}

#}</code></pre></pre>
<p>generates a 710 byte wasm binary:</p>
<pre><code>$ ls -l add_bg.wasm
-rw-rw-r-- 1 alex alex 710 Sep 19 17:32 add_bg.wasm
</code></pre>
<p>If you run <a href="https://github.com/webassembly/binaryen">wasm-opt</a>, a C++ tool for optimize WebAssembly, you can make it
even smaller too!</p>
<pre><code>$ wasm-opt -Os add_bg.wasm -o add.wasm
$ ls -l add.wasm
-rw-rw-r-- 1 alex alex 172 Sep 19 17:33 add.wasm
</code></pre>
<p>And sure enough, using the <a href="https://github.com/webassembly/wabt">wasm2wat</a> tool it's quite small!</p>
<pre><code>$ wasm2wat add.wasm
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    get_local 1
    get_local 0
    i32.add)
  (table (;0;) 1 1 anyfunc)
  (memory (;0;) 17)
  (global (;0;) i32 (i32.const 1049118))
  (global (;1;) i32 (i32.const 1049118))
  (export &quot;memory&quot; (memory 0))
  (export &quot;__indirect_function_table&quot; (table 0))
  (export &quot;__heap_base&quot; (global 0))
  (export &quot;__data_end&quot; (global 1))
  (export &quot;add&quot; (func 0))
  (data (i32.const 1049096) &quot;invalid malloc request&quot;))
</code></pre>
<p>Also don't forget to compile in release mode for the smallest binaries! For
larger applications you'll likely also want to turn on LTO to generate the
smallest binaries:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<a class="header" href="#using---no-modules" id="using---no-modules"><h1>Using <code>--no-modules</code></h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/no_modules">View full source code</a></p>
<p>This example shows how the <code>--no-modules</code> flag can be used load code in a
browser directly (using the same code as the <a href="hello-world.html">hello world example</a>).
Most of the magic happens in <code>index.html</code>:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;meta content=&quot;text/html;charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      // The `--no-modules`-generated JS from `wasm-bindgen` attempts to use
      // `WebAssembly.instantiateStreaming` to instantiate the wasm module,
      // but this doesn't work with `file://` urls. This example is frequently
      // viewed by simply opening `index.html` in a browser (with a `file://`
      // url), so it would fail if we were to call this function!
      //
      // Work around this for now by deleting the function to ensure that the
      // `no_modules.js` script doesn't have access to it. You won't need this
      // hack when deploying over HTTP.
      delete WebAssembly.instantiateStreaming;
    &lt;/script&gt;

    &lt;!-- this is the JS generated by the `wasm-bindgen` CLI tool --&gt;
    &lt;script src='./no_modules.js'&gt;&lt;/script&gt;

    &lt;script&gt;
      // the `wasm_bindgen` global is set to the exports of the Rust module
      const { greet } = wasm_bindgen;

      // we'll defer our execution until the wasm is ready to go
      function run() {
          greet('World');
      }

      // here we tell bindgen the path to the wasm file so it can run
      // initialization and return to us a promise when it's done
      wasm_bindgen('./no_modules_bg.wasm').then(run);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>And that's it! It's worth pointing out that if <a href="../reference/attributes/on-js-imports/module.html"><code>#[wasm_bindgen(module = &quot;...&quot;)]</code> imports are used</a> then <code>wasm-bindgen --no-modules</code> will fail
(as it doesn't know how to import modules).</p>
<a class="header" href="#converting-webassembly-to-js" id="converting-webassembly-to-js"><h1>Converting WebAssembly to JS</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/wasm2js">View full source code</a></p>
<p>Not all browsers have support for <code>WebAssembly</code> at this time (although all major
ones do). If you'd like to support older browsers, you probably want a method
that doesn't involve keeping two codebases in sync!</p>
<p>Thankfully there's a tool from <a href="https://github.com/WebAssembly/binaryen">binaryen</a> called <code>wasm2js</code> to convert a wasm
file to JS. This JS file, if successfully produced, is equivalent to the wasm
file (albeit a little bit larger and slower), and can be loaded into practically
any browser.</p>
<p>This example is relatively simple (cribbing from the [<code>console.log</code>
example][console_log]):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

// lifted from the `console_log` example
#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[wasm_bindgen]
pub fn run() {
    log(&quot;Hello, World!&quot;);
}

#}</code></pre></pre>
<p>The real magic happens when you actually build the app. Just after
<code>wasm-bindgen</code> we see here how we execute <code>wasm2js</code> in our build script:</p>
<pre><code class="language-sh">#!/bin/sh

set -ex

# Compile our wasm module and run `wasm-bindgen`
cargo +nightly build --target wasm32-unknown-unknown --release
cargo +nightly run --manifest-path ../../crates/cli/Cargo.toml \
  --bin wasm-bindgen -- \
  ../../target/wasm32-unknown-unknown/release/wasm2js.wasm --out-dir .

# Run the `wasm2js` tool from `binaryen`
wasm2js wasm2js_bg.wasm -o wasm2js_bg.js

# Move our original wasm out of the way to avoid cofusing Webpack.
mv wasm2js_bg.wasm wasm2js_bg.bak.wasm

npm install
npm run serve

</code></pre>
<p>Note that the <code>wasm2js</code> tool is still pretty early days so there's likely to be
a number of bugs to run into or work around. If any are encountered though
please feel free to report them upstream!</p>
<p>Also note that eventually this will ideally be automatically done by your
bundler and no action would be needed from you to work in older browsers via
<code>wasm2js</code>!</p>
<a class="header" href="#importing-non-browser-js" id="importing-non-browser-js"><h1>Importing non-browser JS</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/import_js">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/import_js/">view the compiled example online</a></p>
<p>The <code>#[wasm_bindgen]</code> attribute can be used on <code>extern { .. }</code> blocks to import
functionality from JS. This is how the <code>js-sys</code> and the <code>web-sys</code> crates are
built, but you can also use it in your own crate!</p>
<p>For example if you're working with this JS file:</p>
<pre><code class="language-js">// defined-in-js.js
export function name() {
    return 'World';
}

export class MyClass {
    constructor() {
        this._number = 42;
    }

    get number() {
        return this._number;
    }

    set number(n) {
        return this._number = n;
    }

    render() {
        return `My number is: ${this.number}`;
    }
}

</code></pre>
<p>you can use it in Rust with:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen(module = &quot;./defined-in-js&quot;)]
extern &quot;C&quot; {
    fn name() -&gt; String;

    type MyClass;

    #[wasm_bindgen(constructor)]
    fn new() -&gt; MyClass;

    #[wasm_bindgen(method, getter)]
    fn number(this: &amp;MyClass) -&gt; u32;
    #[wasm_bindgen(method, setter)]
    fn set_number(this: &amp;MyClass, number: u32) -&gt; MyClass;
    #[wasm_bindgen(method)]
    fn render(this: &amp;MyClass) -&gt; String;
}

// lifted from the `console_log` example
#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[wasm_bindgen]
pub fn run() {
    log(&amp;format!(&quot;Hello, {}!&quot;, name()));

    let x = MyClass::new();
    assert_eq!(x.number(), 42);
    x.set_number(10);
    log(&amp;x.render());
}

#}</code></pre></pre>
<p>You can also <a href="../reference/attributes/on-js-imports/index.html">explore the full list of ways to configure imports</a></p>
<a class="header" href="#working-with-the-char-type" id="working-with-the-char-type"><h1>Working with the <code>char</code> type</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/char">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/char/">view the compiled example online</a></p>
<p>The <code>#[wasm_bindgen]</code> macro will convert the rust <code>char</code> type to a single
code-point js <code>string</code>, and this example shows how to work with this.</p>
<p>Opening this example should display a single counter with a random character
for it's <code>key</code> and 0 for its <code>count</code>. You can click the <code>+</code> button to increase a
counter's count. By clicking on the &quot;add counter&quot; button you should see a new
counter added to the list with a different random character for it's <code>key</code>.</p>
<p>Under the hood javascript is choosing a random character from an Array of
characters and passing that to the rust Counter struct's constructor so the
character you are seeing on the page has made the full round trip from js to
rust and back to js.</p>
<a class="header" href="#srclibrs-2" id="srclibrs-2"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

// lifted from the `console_log` example
#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[wasm_bindgen]
#[derive(Debug)]
pub struct Counter {
    key: char,
    count: i32,
}

#[wasm_bindgen]
impl Counter {
    pub fn default() -&gt; Counter {
        log(&quot;Counter::default&quot;);
        Self::new('a', 0)
    }
    pub fn new(key: char, count: i32) -&gt; Counter {
        log(&amp;format!(&quot;Counter::new({}, {})&quot;, key, count));
        Counter {
            key: key,
            count: count,
        }
    }

    pub fn key(&amp;self) -&gt; char {
        log(&quot;Counter.key()&quot;);
        self.key
    }

    pub fn count(&amp;self) -&gt; i32 {
        log(&quot;Counter.count&quot;);
        self.count
    }

    pub fn increment(&amp;mut self) {
        log(&quot;Counter.increment&quot;);
        self.count += 1;
    }

    pub fn update_key(&amp;mut self, key: char) {
        self.key = key;
    }
}

#}</code></pre></pre>
<a class="header" href="#indexjs-1" id="indexjs-1"><h2><code>index.js</code></h2></a>
<pre><code class="language-js">/* eslint-disable no-unused-vars */
import { chars } from './chars-list.js';
let imp = import('./char.js');
let mod;

let counters = [];
imp.then(wasm =&gt; {
    mod = wasm;
    addCounter();
    let b = document.getElementById('add-counter');
    if (!b) throw new Error('Unable to find #add-counter');
    b.addEventListener('click', ev =&gt; addCounter());
});

function addCounter() {
    let ctr = mod.Counter.new(randomChar(), 0);
    counters.push(ctr);
    update();
}

function update() {
    let container = document.getElementById('container');
    if (!container) throw new Error('Unable to find #container in dom');
    while (container.hasChildNodes()) {
        if (container.lastChild.id == 'add-counter') break;
        container.removeChild(container.lastChild);
    }
    for (var i = 0; i &lt; counters.length; i++) {
        let counter = counters[i];
        container.appendChild(newCounter(counter.key(), counter.count(), ev =&gt; {
            counter.increment();
            update();
        }));
    }
}

function randomChar() {
    console.log('randomChar');
    let idx = Math.floor(Math.random() * (chars.length - 1));
    console.log('index', idx);
    let ret = chars.splice(idx, 1)[0];
    console.log('char', ret);
    return ret;
}

function newCounter(key, value, cb) {
    let container = document.createElement('div');
    container.setAttribute('class', 'counter');
    let title = document.createElement('h1');
    title.appendChild(document.createTextNode('Counter ' + key));
    container.appendChild(title);
    container.appendChild(newField('Count', value));
    let plus = document.createElement('button');
    plus.setAttribute('type', 'button');
    plus.setAttribute('class', 'plus-button');
    plus.appendChild(document.createTextNode('+'));
    plus.addEventListener('click', cb);
    container.appendChild(plus);
    return container;
}

function newField(key, value) {
    let ret = document.createElement('div');
    ret.setAttribute('class', 'field');
    let name = document.createElement('span');
    name.setAttribute('class', 'name');
    name.appendChild(document.createTextNode(key));
    ret.appendChild(name);
    let val = document.createElement('span');
    val.setAttribute('class', 'value');
    val.appendChild(document.createTextNode(value));
    ret.appendChild(val);
    return ret;
}

</code></pre>
<a class="header" href="#js-sys-webassembly-in-webassembly" id="js-sys-webassembly-in-webassembly"><h1>js-sys: WebAssembly in WebAssembly</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/wasm-in-wasm">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/wasm-in-wasm/">view the compiled example online</a></p>
<p>Using the <code>js-sys</code> crate we can get pretty meta and instantiate <code>WebAssembly</code>
modules from inside <code>WebAssembly</code> modules!</p>
<a class="header" href="#srclibrs-3" id="srclibrs-3"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;

use js_sys::{Function, Object, Reflect, Uint8Array, WebAssembly};
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

// lifted from the `console_log` example
#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &amp;str);
}

macro_rules! console_log {
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

const WASM: &amp;[u8] = include_bytes!(&quot;add.wasm&quot;);

#[wasm_bindgen]
pub fn run() -&gt; Result&lt;(), JsValue&gt; {
    console_log!(&quot;instantiating a new wasm module directly&quot;);
    let my_memory = wasm_bindgen::memory()
        .dyn_into::&lt;WebAssembly::Memory&gt;()
        .unwrap();

    // Note that this is somewhat dangerous, once we look at our
    // `WebAssembly.Memory` buffer then if we allocate more pages for ourself
    // (aka do a memory allocation in Rust) it'll cause the buffer to change.
    // That means we can't actually do any memory allocations after we do this
    // until we pass it back to JS.
    let my_memory = Uint8Array::new(&amp;my_memory.buffer()).subarray(
        WASM.as_ptr() as u32,
        WASM.as_ptr() as u32 + WASM.len() as u32,
    );
    let a = WebAssembly::Module::new(my_memory.as_ref())?;
    let b = WebAssembly::Instance::new(&amp;a, &amp;Object::new())?;
    let c = b.exports();

    let add = Reflect::get(c.as_ref(), &amp;&quot;add&quot;.into())?
        .dyn_into::&lt;Function&gt;()
        .expect(&quot;add export wasn't a function&quot;);

    let three = add.call2(&amp;JsValue::undefined(), &amp;1.into(), &amp;2.into())?;
    console_log!(&quot;1 + 2 = {:?}&quot;, three);
    let mem = Reflect::get(c.as_ref(), &amp;&quot;memory&quot;.into())?
        .dyn_into::&lt;WebAssembly::Memory&gt;()
        .expect(&quot;memory export wasn't a `WebAssembly.Memory`&quot;);
    console_log!(&quot;created module has {} pages of memory&quot;, mem.grow(0));
    console_log!(&quot;giving the module 4 more pages of memory&quot;);
    mem.grow(4);
    console_log!(&quot;now the module has {} pages of memory&quot;, mem.grow(0));

    Ok(())
}

#}</code></pre></pre>
<a class="header" href="#web-sys-dom-hello-world" id="web-sys-dom-hello-world"><h1>web-sys: DOM hello world</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/dom">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/dom/">view the compiled example online</a></p>
<p>Using <code>web-sys</code> we're able to interact with all the standard web platform
methods, including those of the DOM! Here we take a look at a simple &quot;Hello,
world!&quot; which manufactures a DOM element in Rust, customizes it, and then
appends it to the page.</p>
<a class="header" href="#cargotoml-1" id="cargotoml-1"><h2><code>Cargo.toml</code></h2></a>
<p>You can see here how we depend on <code>web-sys</code> and activate associated features to
enable all the various APIs:</p>
<pre><code class="language-toml">[package]
name = &quot;dom&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = { path = &quot;../..&quot; }

[dependencies.web-sys]
path = '../../crates/web-sys'
features = [
  'Document',
  'Element',
  'HtmlElement',
  'Node',
  'Window',
]

</code></pre>
<a class="header" href="#srclibrs-4" id="srclibrs-4"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;
extern crate web_sys;

use wasm_bindgen::prelude::*;

// Called by our JS entry point to run the example
#[wasm_bindgen]
pub fn run() -&gt; Result&lt;(), JsValue&gt; {
    // Use `web_sys`'s global `window` function to get a handle on the global
    // window object.
    let window = web_sys::window().expect(&quot;no global `window` exists&quot;);
    let document = window.document().expect(&quot;should have a document on window&quot;);
    let body = document.body().expect(&quot;document should have a body&quot;);

    // Manufacture the element we're gonna append
    let val = document.create_element(&quot;p&quot;)?;
    val.set_inner_html(&quot;Hello from Rust!&quot;);

    // Right now the class inheritance hierarchy of the DOM isn't super
    // ergonomic, so we manually cast `val: Element` to `&amp;Node` to call the
    // `append_child` method.
    AsRef::&lt;web_sys::Node&gt;::as_ref(&amp;body).append_child(val.as_ref())?;

    Ok(())
}

#}</code></pre></pre>
<a class="header" href="#web-sys-closures" id="web-sys-closures"><h1>web-sys: Closures</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/closures">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/closures/">view the compiled example online</a></p>
<p>One of the features of <code>#[wasm_bindgen]</code> is that you can pass closures defined
in Rust off to JS. This can be a bit tricky at times, though, so the example
here shows how to interact with some standard web APIs with closures.</p>
<a class="header" href="#srclibrs-5" id="srclibrs-5"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;
extern crate js_sys;
extern crate web_sys;

use js_sys::{Date, Array};
use wasm_bindgen::JsCast;
use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, Window};

#[wasm_bindgen]
pub fn run() -&gt; Result&lt;(), JsValue&gt; {
    let window = web_sys::window().expect(&quot;should have a window in this context&quot;);
    let document = window.document().expect(&quot;window should have a document&quot;);

    // One of the first interesting things we can do with closures is simply
    // access stack data in Rust!
    let array = Array::new();
    array.push(&amp;&quot;Hello&quot;.into());
    array.push(&amp;1.into());
    let mut first_item = None;
    array.for_each(&amp;mut |obj, idx, _arr| {
        match idx {
            0 =&gt; {
                assert_eq!(obj, &quot;Hello&quot;);
                first_item = obj.as_string();
            }
            1 =&gt; assert_eq!(obj, 1),
            _ =&gt; panic!(&quot;unknown index: {}&quot;, idx)
        }
    });
    assert_eq!(first_item, Some(&quot;Hello&quot;.to_string()));

    // Below are some more advanced usages of the `Closure` type for closures
    // that need to live beyond our function call.

    setup_clock(&amp;window, &amp;document)?;
    setup_clicker(&amp;document);

    // And now that our demo is ready to go let's switch things up so
    // everything is displayed and our loading prompt is hidden.
    document
        .get_element_by_id(&quot;loading&quot;)
        .expect(&quot;should have #loading on the page&quot;)
        .dyn_ref::&lt;HtmlElement&gt;()
        .expect(&quot;#loading should be an `HtmlElement`&quot;)
        .style()
        .set_property(&quot;display&quot;, &quot;none&quot;)?;
    document
        .get_element_by_id(&quot;script&quot;)
        .expect(&quot;should have #script on the page&quot;)
        .dyn_ref::&lt;HtmlElement&gt;()
        .expect(&quot;#script should be an `HtmlElement`&quot;)
        .style()
        .set_property(&quot;display&quot;, &quot;block&quot;)?;

    Ok(())
}

// Set up a clock on our page and update it each second to ensure it's got
// an accurate date.
//
// Note the usage of `Closure` here because the closure is &quot;long lived&quot;,
// basically meaning it has to persist beyond the call to this one function.
// Also of note here is the `.as_ref().unchecked_ref()` chain, which is who
// you can extract `&amp;Function`, what `web-sys` expects, from a `Closure`
// which only hands you `&amp;JsValue` via `AsRef`.
fn setup_clock(window: &amp;Window, document: &amp;Document) -&gt; Result&lt;(), JsValue&gt; {
    let current_time = document
        .get_element_by_id(&quot;current-time&quot;)
        .expect(&quot;should have #current-time on the page&quot;);
    update_time(&amp;current_time);
    let a = Closure::wrap(Box::new(move || {
        update_time(&amp;current_time)
    }) as Box&lt;Fn()&gt;);
    window.set_interval_with_callback_and_timeout_and_arguments_0(
        a.as_ref().unchecked_ref(),
        1000,
    )?;
    fn update_time(current_time: &amp;Element) {
        current_time
            .set_inner_html(&amp;String::from(
                Date::new_0().to_locale_string(&quot;en-GB&quot;, &amp;JsValue::undefined()),
            ));
    }

    // The instances of `Closure` that we created will invalidate their
    // corresponding JS callback whenever they're dropped, so if we were to
    // normally return from `run` then both of our registered closures will
    // raise exceptions when invoked.
    //
    // Normally we'd store these handles to later get dropped at an appropriate
    // time but for now we want these to be global handlers so we use the
    // `forget` method to drop them without invalidating the closure. Note that
    // this is leaking memory in Rust, so this should be done judiciously!
    a.forget();

    Ok(())
}

// We also want to count the number of times that our green square has been
// clicked. Our callback will update the `#num-clicks` div.
//
// This is pretty similar above, but showing how closures can also implement
// `FnMut()`.
fn setup_clicker(document: &amp;Document) {
    let num_clicks = document
        .get_element_by_id(&quot;num-clicks&quot;)
        .expect(&quot;should have #num-clicks on the page&quot;);
    let mut clicks = 0;
    let a = Closure::wrap(Box::new(move || {
        clicks += 1;
        num_clicks.set_inner_html(&amp;clicks.to_string());
    }) as Box&lt;FnMut()&gt;);
    document
        .get_element_by_id(&quot;green-square&quot;)
        .expect(&quot;should have #green-square on the page&quot;)
        .dyn_ref::&lt;HtmlElement&gt;()
        .expect(&quot;#green-square be an `HtmlElement`&quot;)
        .set_onclick(Some(a.as_ref().unchecked_ref()));
    a.forget();
}

#}</code></pre></pre>
<a class="header" href="#web-sys-performancenow" id="web-sys-performancenow"><h1>web-sys: <code>performance.now</code></h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/performance">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/performance/">view the compiled example online</a></p>
<p>Want to profile some Rust code in the browser? No problem! You can use the
<code>performance.now()</code> API and friends to get timing information to see how long
things take.</p>
<a class="header" href="#srclibrs-6" id="srclibrs-6"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate humantime;
extern crate wasm_bindgen;
extern crate web_sys;

use std::time::{Duration, SystemTime, UNIX_EPOCH};

use wasm_bindgen::prelude::*;

// lifted from the `console_log` example
#[wasm_bindgen]
extern &quot;C&quot; {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &amp;str);
}

macro_rules! console_log {
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

// Called by our JS entry point to run the example
#[wasm_bindgen]
pub fn run() {
    let window = web_sys::window().expect(&quot;should have a window in this context&quot;);
    let performance = window.performance().expect(&quot;performance should be available&quot;);

    console_log!(&quot;the current time (in ms) is {}&quot;, performance.now());

    let start = perf_to_system(performance.timing().request_start());
    let end = perf_to_system(performance.timing().response_end());

    console_log!(&quot;request started at {}&quot;, humantime::format_rfc3339(start));
    console_log!(&quot;request ended at {}&quot;, humantime::format_rfc3339(end));
}

fn perf_to_system(amt: f64) -&gt; SystemTime {
    let secs = (amt as u64) / 1_000;
    let nanos = ((amt as u32) % 1_000) * 1_000_000;
    UNIX_EPOCH + Duration::new(secs, nanos)
}

#}</code></pre></pre>
<a class="header" href="#the-fetch-api" id="the-fetch-api"><h1>The <code>fetch</code> API</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/fetch">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/fetch/">view the compiled example online</a></p>
<p>This example uses the <code>fetch</code> API to make an HTTP request to the GitHub API and
then parses the resulting JSON.</p>
<a class="header" href="#cargotoml-2" id="cargotoml-2"><h2><code>Cargo.toml</code></h2></a>
<p>The <code>Cargo.toml</code> enables a number of features related to the <code>fetch</code> API and
types used: <code>Headers</code>, <code>Request</code>, etc. It also enables <code>wasm-bindgen</code>'s <code>serde</code>
support.</p>
<pre><code class="language-toml">[package]
name = &quot;fetch&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
futures = &quot;0.1.20&quot;
wasm-bindgen = { path = &quot;../..&quot;, features = [&quot;serde-serialize&quot;]  }
js-sys = { path = &quot;../../crates/js-sys&quot; }
wasm-bindgen-futures = { path = &quot;../../crates/futures&quot; }
serde = &quot;^1.0.59&quot;
serde_derive = &quot;^1.0.59&quot;

[dependencies.web-sys]
path = &quot;../../crates/web-sys&quot;
features = [
  'Headers',
  'Request',
  'RequestInit',
  'RequestMode',
  'Response',
  'Window',
]

</code></pre>
<a class="header" href="#srclibrs-7" id="srclibrs-7"><h2><code>src/lib.rs</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate futures;
extern crate js_sys;
extern crate wasm_bindgen;
extern crate wasm_bindgen_futures;
extern crate web_sys;
#[macro_use]
extern crate serde_derive;

use futures::{future, Future};
use js_sys::Promise;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use wasm_bindgen_futures::future_to_promise;
use wasm_bindgen_futures::JsFuture;
use web_sys::{Request, RequestInit, RequestMode, Response};

/// A struct to hold some data from the github Branch API.
///
/// Note how we don't have to define every member -- serde will ignore extra
/// data when deserializing
#[derive(Debug, Serialize, Deserialize)]
pub struct Branch {
    pub name: String,
    pub commit: Commit,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Commit {
    pub sha: String,
    pub commit: CommitDetails,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CommitDetails {
    pub author: Signature,
    pub committer: Signature,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Signature {
    pub name: String,
    pub email: String,
}

#[wasm_bindgen]
pub fn run() -&gt; Promise {
    let mut opts = RequestInit::new();
    opts.method(&quot;GET&quot;);
    opts.mode(RequestMode::Cors);

    let request = Request::new_with_str_and_init(
        &quot;https://api.github.com/repos/rustwasm/wasm-bindgen/branches/master&quot;,
        &amp;opts,
    ).unwrap();

    request.headers()
        .set(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)
        .unwrap();

    let window = web_sys::window().unwrap();
    let request_promise = window.fetch_with_request(&amp;request);

    let future = JsFuture::from(request_promise)
        .and_then(|resp_value| {
            // `resp_value` is a `Response` object.
            assert!(resp_value.is_instance_of::&lt;Response&gt;());
            let resp: Response = resp_value.dyn_into().unwrap();
            resp.json()
        }).and_then(|json_value: Promise| {
            // Convert this other `Promise` into a rust `Future`.
            JsFuture::from(json_value)
        }).and_then(|json| {
            // Use serde to parse the JSON into a struct.
            let branch_info: Branch = json.into_serde().unwrap();

            // Send the `Branch` struct back to JS as an `Object`.
            future::ok(JsValue::from_serde(&amp;branch_info).unwrap())
        });

    // Convert this Rust `Future` back into a JS `Promise`.
    future_to_promise(future)
}

#}</code></pre></pre>
<a class="header" href="#a2d-canvas" id="a2d-canvas"><h1>2D Canvas</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/canvas">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/canvas/">view the compiled example online</a></p>
<p>Drawing a smiley face with the 2D canvas API. This is a port of part of <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes#Moving_the_pen">this
MDN
tutorial</a>
to <code>web-sys</code>.</p>
<p><img src="./2d-canvas.png" alt="A smiley face" /></p>
<a class="header" href="#cargotoml-3" id="cargotoml-3"><h2><code>Cargo.toml</code></h2></a>
<p>The <code>Cargo.toml</code> enables features necessary to query the DOM and work with 2D
canvas.</p>
<pre><code class="language-toml">[package]
name = &quot;canvas&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
js-sys = { path = &quot;../../crates/js-sys&quot; }
wasm-bindgen = { path = &quot;../..&quot; }

[dependencies.web-sys]
path = &quot;../../crates/web-sys&quot;
features = [
  'CanvasRenderingContext2d',
  'Document',
  'Element',
  'HtmlCanvasElement',
  'Window',
]

</code></pre>
<a class="header" href="#srclibrs-8" id="srclibrs-8"><h2><code>src/lib.rs</code></h2></a>
<p>Gets the <code>&lt;canvas&gt;</code> element, creates a 2D rendering context, and draws the
smiley face.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;
extern crate web_sys;

use std::f64;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

#[wasm_bindgen]
pub fn draw() {
    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document.get_element_by_id(&quot;canvas&quot;).unwrap();
    let canvas: web_sys::HtmlCanvasElement = canvas
        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
        .map_err(|_| ())
        .unwrap();

    let context = canvas
        .get_context(&quot;2d&quot;)
        .unwrap()
        .unwrap()
        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
        .unwrap();

    context.begin_path();

    // Draw the outer circle.
    context.arc(
        75.0,
        75.0,
        50.0,
        0.0,
        f64::consts::PI * 2.0,
    ).unwrap();

    // Draw the mouth.
    context.move_to(110.0, 75.0);
    context.arc(
        75.0,
        75.0,
        35.0,
        0.0,
        f64::consts::PI,
    ).unwrap();

    // Draw the left eye.
    context.move_to(65.0, 65.0);
    context.arc(
        60.0,
        65.0,
        5.0,
        0.0,
        f64::consts::PI * 2.0,
    ).unwrap();

    // Draw the right eye.
    context.move_to(95.0, 65.0);
    context.arc(
        90.0,
        65.0,
        5.0,
        0.0,
        f64::consts::PI * 2.0,
    ).unwrap();

    context.stroke();
}

#}</code></pre></pre>
<a class="header" href="#julia-set" id="julia-set"><h1>Julia Set</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/julia_set">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/julia_set/">view the compiled example online</a></p>
<p>While not showing off a lot of <code>web_sys</code> API surface area, this example shows a
neat fractal that you can make!</p>
<a class="header" href="#indexjs-2" id="indexjs-2"><h2><code>index.js</code></h2></a>
<p>A small bit of glue is added for this example</p>
<pre><code class="language-js">import('./julia_set')
    .then(wasm =&gt; {
        const canvas = document.getElementById('drawing');
        const ctx = canvas.getContext('2d');
        
        const realInput = document.getElementById('real');
        const imaginaryInput = document.getElementById('imaginary');
        const renderBtn = document.getElementById('render');

        renderBtn.addEventListener('click', () =&gt; {
            const real = parseFloat(realInput.value) || 0;
            const imaginary = parseFloat(imaginaryInput.value) || 0;
            wasm.draw(ctx, 600, 600, real, imaginary);
        });
        
        wasm.draw(ctx, 600, 600, -0.15, 0.65);
    });

</code></pre>
<a class="header" href="#srclibrs-9" id="srclibrs-9"><h2><code>src/lib.rs</code></h2></a>
<p>The bulk of the logic is in the generation of the fractal</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;
extern crate web_sys;

use std::ops::Add;
use wasm_bindgen::Clamped;
use wasm_bindgen::prelude::*;
use web_sys::{CanvasRenderingContext2d, ImageData};

#[wasm_bindgen]
pub fn draw(
    ctx: &amp;CanvasRenderingContext2d,
    width: u32,
    height: u32,
    real: f64,
    imaginary: f64,
) -&gt; Result&lt;(), JsValue&gt; {
    // The real workhorse of this algorithm, generating pixel data
    let c = Complex { real, imaginary, };
    let mut data = get_julia_set(width, height, c);
    let data = ImageData::new_with_u8_clamped_array_and_sh(Clamped(&amp;mut data), width, height)?;
    ctx.put_image_data(&amp;data, 0.0, 0.0)
}

fn get_julia_set(width: u32, height: u32, c: Complex) -&gt; Vec&lt;u8&gt; {
    let mut data = Vec::new();

    let param_i = 1.5;
    let param_r = 1.5;
    let scale = 0.005;

    for x in 0..width {
        for y in 0..height {
            let z = Complex {
                real: y as f64 * scale - param_r,
                imaginary: x as f64 * scale - param_i,
            };
            let iter_index = get_iter_index(z, c);
            data.push((iter_index / 4) as u8);
            data.push((iter_index / 2) as u8);
            data.push(iter_index as u8);
            data.push(255);
        }
    }

    data
}

fn get_iter_index(z: Complex, c: Complex) -&gt; u32 {
    let mut iter_index: u32 = 0;
    let mut z = z;
    while iter_index &lt; 900 {
        if z.norm() &gt; 2.0 {
            break
        }
        z = z.square() + c;
        iter_index += 1;
    }
    iter_index
}

#[derive(Clone, Copy, Debug)]
struct Complex {
    real: f64,
    imaginary: f64,
}

impl Complex {
    fn square(self) -&gt; Complex {
        let real = (self.real * self.real) - (self.imaginary * self.imaginary);
        let imaginary = 2.0 * self.real * self.imaginary;
        Complex { real, imaginary }
    }

    fn norm(&amp;self) -&gt; f64 {
        (self.real * self.real) + (self.imaginary * self.imaginary)
    }
}

impl Add&lt;Complex&gt; for Complex {
    type Output = Complex;

    fn add(self, rhs: Complex) -&gt; Complex {
        Complex {
            real: self.real + rhs.real,
            imaginary: self.imaginary + rhs.imaginary,
        }
    }
}

#}</code></pre></pre>
<a class="header" href="#webaudio" id="webaudio"><h1>WebAudio</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/webaudio">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/webaudio/">view the compiled example online</a></p>
<p>This example creates an <a href="https://en.wikipedia.org/wiki/Frequency_modulation_synthesis">FM
oscillator</a> using
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">WebAudio
API</a> and
<code>web-sys</code>.</p>
<a class="header" href="#cargotoml-4" id="cargotoml-4"><h2><code>Cargo.toml</code></h2></a>
<p>The <code>Cargo.toml</code> enables the types needed to use the relevant bits of the
WebAudio API.</p>
<pre><code class="language-toml">[package]
name = &quot;webaudio&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = { path = &quot;../..&quot; }

[dependencies.web-sys]
path = &quot;../../crates/web-sys&quot;
features = [
  'AudioContext',
  'AudioDestinationNode',
  'AudioNode',
  'AudioParam',
  'AudioScheduledSourceNode',
  'BaseAudioContext',
  'GainNode',
  'OscillatorNode',
  'OscillatorType',
]

</code></pre>
<a class="header" href="#srclibrs-10" id="srclibrs-10"><h2><code>src/lib.rs</code></h2></a>
<p>The Rust code implements the FM oscillator.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;
extern crate web_sys;

use wasm_bindgen::prelude::*;
use web_sys::{
    AudioContext, AudioNode, AudioScheduledSourceNode, BaseAudioContext, OscillatorType,
};

/// Converts a midi note to frequency
///
/// A midi note is an integer, generally in the range of 21 to 108
pub fn midi_to_freq(note: u8) -&gt; f32 {
    27.5 * 2f32.powf((note as f32 - 21.0) / 12.0)
}

#[wasm_bindgen]
pub struct FmOsc {
    ctx: AudioContext,
    /// The primary oscillator.  This will be the fundamental frequency
    primary: web_sys::OscillatorNode,

    /// Overall gain (volume) control
    gain: web_sys::GainNode,

    /// Amount of frequency modulation
    fm_gain: web_sys::GainNode,

    /// The oscillator that will modulate the primary oscillator's frequency
    fm_osc: web_sys::OscillatorNode,

    /// The ratio between the primary frequency and the fm_osc frequency.
    ///
    /// Generally fractional values like 1/2 or 1/4 sound best
    fm_freq_ratio: f32,

    fm_gain_ratio: f32,
}

#[wasm_bindgen]
impl FmOsc {
    #[wasm_bindgen(constructor)]
    pub fn new() -&gt; FmOsc {
        let ctx = web_sys::AudioContext::new().unwrap();
        let primary;
        let fm_osc;
        let gain;
        let fm_gain;

        {
            let base: &amp;BaseAudioContext = ctx.as_ref();

            // Create our web audio objects.
            primary = base.create_oscillator().unwrap();
            fm_osc = base.create_oscillator().unwrap();
            gain = base.create_gain().unwrap();
            fm_gain = base.create_gain().unwrap();
        }

        // Some initial settings:
        primary.set_type(OscillatorType::Sine);
        primary.frequency().set_value(440.0); // A4 note
        gain.gain().set_value(0.0); // starts muted
        fm_gain.gain().set_value(0.0); // no initial frequency modulation
        fm_osc.set_type(OscillatorType::Sine);
        fm_osc.frequency().set_value(0.0);

        // Create base class references:
        {
            let primary_node: &amp;AudioNode = primary.as_ref();
            let gain_node: &amp;AudioNode = gain.as_ref();
            let fm_osc_node: &amp;AudioNode = fm_osc.as_ref();
            let fm_gain_node: &amp;AudioNode = fm_gain.as_ref();
            let base: &amp;BaseAudioContext = ctx.as_ref();
            let destination = base.destination();
            let destination_node: &amp;AudioNode = destination.as_ref();

            // Connect the nodes up!

            // The primary oscillator is routed through the gain node, so that
            // it can control the overall output volume.
            primary_node.connect_with_audio_node(gain.as_ref()).unwrap();

            // Then connect the gain node to the AudioContext destination (aka
            // your speakers).
            gain_node.connect_with_audio_node(destination_node).unwrap();

            // The FM oscillator is connected to its own gain node, so it can
            // control the amount of modulation.
            fm_osc_node
                .connect_with_audio_node(fm_gain.as_ref())
                .unwrap();

            // Connect the FM oscillator to the frequency parameter of the main
            // oscillator, so that the FM node can modulate its frequency.
            fm_gain_node
                .connect_with_audio_param(&amp;primary.frequency())
                .unwrap();
        }

        // Start the oscillators!
        AsRef::&lt;AudioScheduledSourceNode&gt;::as_ref(&amp;primary)
            .start()
            .unwrap();
        AsRef::&lt;AudioScheduledSourceNode&gt;::as_ref(&amp;fm_osc)
            .start()
            .unwrap();

        FmOsc {
            ctx,
            primary,
            gain,
            fm_gain,
            fm_osc,
            fm_freq_ratio: 0.0,
            fm_gain_ratio: 0.0,
        }
    }

    /// Sets the gain for this oscillator, between 0.0 and 1.0.
    #[wasm_bindgen]
    pub fn set_gain(&amp;self, mut gain: f32) {
        if gain &gt; 1.0 {
            gain = 1.0;
        }
        if gain &lt; 0.0 {
            gain = 0.0;
        }
        self.gain.gain().set_value(gain);
    }

    #[wasm_bindgen]
    pub fn set_primary_frequency(&amp;self, freq: f32) {
        self.primary.frequency().set_value(freq);

        // The frequency of the FM oscillator depends on the frequency of the
        // primary oscillator, so we update the frequency of both in this method.
        self.fm_osc.frequency().set_value(self.fm_freq_ratio * freq);
        self.fm_gain.gain().set_value(self.fm_gain_ratio * freq);
    }

    #[wasm_bindgen]
    pub fn set_note(&amp;self, note: u8) {
        let freq = midi_to_freq(note);
        self.set_primary_frequency(freq);
    }

    /// This should be between 0 and 1, though higher values are accepted.
    #[wasm_bindgen]
    pub fn set_fm_amount(&amp;mut self, amt: f32) {
        self.fm_gain_ratio = amt;

        self.fm_gain
            .gain()
            .set_value(self.fm_gain_ratio * self.primary.frequency().value());
    }

    /// This should be between 0 and 1, though higher values are accepted.
    #[wasm_bindgen]
    pub fn set_fm_frequency(&amp;mut self, amt: f32) {
        self.fm_freq_ratio = amt;
        self.fm_osc
            .frequency()
            .set_value(self.fm_freq_ratio * self.primary.frequency().value());
    }
}

#}</code></pre></pre>
<a class="header" href="#indexjs-3" id="indexjs-3"><h2><code>index.js</code></h2></a>
<p>A small bit of JavaScript glues the rust module to input widgets and translates
events into calls into wasm code.</p>
<pre><code class="language-js">import('./webaudio').then(rust_module =&gt; {
  let fm = null;

  const play_button = document.getElementById(&quot;play&quot;);
  play_button.addEventListener(&quot;click&quot;, event =&gt; {
    if (fm === null) {
      fm = new rust_module.FmOsc();
      fm.set_note(50);
      fm.set_fm_frequency(0);
      fm.set_fm_amount(0);
      fm.set_gain(0.8);
    }
  });

  const primary_slider = document.getElementById(&quot;primary_input&quot;);
  primary_slider.addEventListener(&quot;input&quot;, event =&gt; {
    if (fm) {
      fm.set_note(event.target.value);
    }
  });

  const fm_freq = document.getElementById(&quot;fm_freq&quot;);
  fm_freq.addEventListener(&quot;input&quot;, event =&gt; {
    if (fm) {
      fm.set_fm_frequency(event.target.value);
    }
  });

  const fm_amount = document.getElementById(&quot;fm_amount&quot;);
  fm_amount.addEventListener(&quot;input&quot;, event =&gt; {
    if (fm) {
      fm.set_fm_amount(event.target.value);
    }
  });
});

</code></pre>
<a class="header" href="#webgl-example" id="webgl-example"><h1>WebGL Example</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/webgl">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/webgl/">view the compiled example online</a></p>
<p>This example draws a triangle to the screen using the WebGL API.</p>
<a class="header" href="#cargotoml-5" id="cargotoml-5"><h2><code>Cargo.toml</code></h2></a>
<p>The <code>Cargo.toml</code> enables features necessary to obtain and use a WebGL
rendering context.</p>
<pre><code class="language-toml">[package]
name = &quot;webgl&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
js-sys = { path = &quot;../../crates/js-sys&quot; }
wasm-bindgen = { path = &quot;../..&quot; }

[dependencies.web-sys]
path = &quot;../../crates/web-sys&quot;
features = [
  'Document',
  'Element',
  'HtmlCanvasElement',
  'WebGlBuffer',
  'WebGlRenderingContext',
  'WebGlProgram',
  'WebGlShader',
  'Window',
]

</code></pre>
<a class="header" href="#srclibrs-11" id="srclibrs-11"><h2><code>src/lib.rs</code></h2></a>
<p>This source file handles all of the necessary logic to obtain a rendering
context, compile shaders, fill a buffer with vertex coordinates, and draw a
triangle to the screen.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;
extern crate web_sys;

use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{WebGlProgram, WebGlRenderingContext, WebGlShader};

#[wasm_bindgen]
pub fn draw() {
    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document.get_element_by_id(&quot;canvas&quot;).unwrap();
    let canvas: web_sys::HtmlCanvasElement = canvas
        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
        .map_err(|_| ())
        .unwrap();

    let context = canvas
        .get_context(&quot;webgl&quot;)
        .unwrap()
        .unwrap()
        .dyn_into::&lt;WebGlRenderingContext&gt;()
        .unwrap();

    let vert_shader = compile_shader(
        &amp;context,
        WebGlRenderingContext::VERTEX_SHADER,
        r#&quot;
        attribute vec4 position;
        void main() {
            gl_Position = position;
        }
    &quot;#,
    ).unwrap();
    let frag_shader = compile_shader(
        &amp;context,
        WebGlRenderingContext::FRAGMENT_SHADER,
        r#&quot;
        void main() {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
    &quot;#,
    ).unwrap();
    let program = link_program(&amp;context, [vert_shader, frag_shader].iter()).unwrap();
    context.use_program(Some(&amp;program));

    let vertices = [-0.7, -0.7, 0.0, 0.7, -0.7, 0.0, 0.0, 0.7, 0.0];
    let vert_array = js_sys::Float32Array::new(&amp;wasm_bindgen::JsValue::from(vertices.len() as u32));
    for (i, f) in vertices.iter().enumerate() {
        vert_array.fill(*f, i as u32, (i + 1) as u32);
    }

    let buffer = context.create_buffer().unwrap();
    context.bind_buffer(WebGlRenderingContext::ARRAY_BUFFER, Some(&amp;buffer));
    context.buffer_data_with_opt_array_buffer(
        WebGlRenderingContext::ARRAY_BUFFER,
        Some(&amp;vert_array.buffer()),
        WebGlRenderingContext::STATIC_DRAW,
    );
    context.vertex_attrib_pointer_with_i32(0, 3, WebGlRenderingContext::FLOAT, false, 0, 0);
    context.enable_vertex_attrib_array(0);

    context.clear_color(0.0, 0.0, 0.0, 1.0);
    context.clear(WebGlRenderingContext::COLOR_BUFFER_BIT);

    context.draw_arrays(
        WebGlRenderingContext::TRIANGLES,
        0,
        (vertices.len() / 3) as i32,
    );
}

pub fn compile_shader(
    context: &amp;WebGlRenderingContext,
    shader_type: u32,
    source: &amp;str,
) -&gt; Result&lt;WebGlShader, String&gt; {
    let shader = context
        .create_shader(shader_type)
        .ok_or_else(|| String::from(&quot;Unable to create shader object&quot;))?;
    context.shader_source(&amp;shader, source);
    context.compile_shader(&amp;shader);

    if context
        .get_shader_parameter(&amp;shader, WebGlRenderingContext::COMPILE_STATUS)
        .as_bool()
        .unwrap_or(false)
    {
        Ok(shader)
    } else {
        Err(context
            .get_shader_info_log(&amp;shader)
            .unwrap_or_else(|| &quot;Unknown error creating shader&quot;.into()))
    }
}

pub fn link_program&lt;'a, T: IntoIterator&lt;Item = &amp;'a WebGlShader&gt;&gt;(
    context: &amp;WebGlRenderingContext,
    shaders: T,
) -&gt; Result&lt;WebGlProgram, String&gt; {
    let program = context
        .create_program()
        .ok_or_else(|| String::from(&quot;Unable to create shader object&quot;))?;
    for shader in shaders {
        context.attach_shader(&amp;program, shader)
    }
    context.link_program(&amp;program);

    if context
        .get_program_parameter(&amp;program, WebGlRenderingContext::LINK_STATUS)
        .as_bool()
        .unwrap_or(false)
    {
        Ok(program)
    } else {
        Err(context
            .get_program_info_log(&amp;program)
            .unwrap_or_else(|| &quot;Unknown error creating program object&quot;.into()))
    }
}

#}</code></pre></pre>
<a class="header" href="#paint-example" id="paint-example"><h1>Paint Example</h1></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/paint">View full source code</a> or <a href="https://rustwasm.github.io/wasm-bindgen/exbuild/paint/">view the compiled example online</a></p>
<p>A simple painting program.</p>
<a class="header" href="#cargotoml-6" id="cargotoml-6"><h2><code>Cargo.toml</code></h2></a>
<p>The <code>Cargo.toml</code> enables features necessary to work with the DOM, events and
2D canvas.</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-bindgen-paint&quot;
version = &quot;0.1.0&quot;
authors = [&quot;The wasm-bindgen Developers&quot;]

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
js-sys = { path = &quot;../../crates/js-sys&quot; }
wasm-bindgen = { path = &quot;../..&quot;, features = [&quot;nightly&quot;] }

[dependencies.web-sys]
path = &quot;../../crates/web-sys&quot;
features = [
  'CanvasRenderingContext2d',
  'CssStyleDeclaration',
  'Document',
  'Element',
  'EventTarget',
  'HtmlCanvasElement',
  'HtmlElement',
  'MouseEvent',
  'Node',
  'Window',
]

</code></pre>
<a class="header" href="#srclibrs-12" id="srclibrs-12"><h2><code>src/lib.rs</code></h2></a>
<p>Creates the <code>&lt;canvas&gt;</code> element, applies a CSS style to it, adds it to the document,
get a 2D rendering context and adds listeners for mouse events.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate js_sys;
extern crate wasm_bindgen;
extern crate web_sys;

use std::cell::Cell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

#[wasm_bindgen]
pub fn main() {
    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document
        .create_element(&quot;canvas&quot;)
        .unwrap()
        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
        .map_err(|_| ())
        .unwrap();
    (document.body().unwrap().as_ref() as &amp;web_sys::Node)
        .append_child(canvas.as_ref() as &amp;web_sys::Node)
        .unwrap();
    canvas.set_width(640);
    canvas.set_height(480);
    (canvas.as_ref() as &amp;web_sys::HtmlElement)
        .style()
        .set_property(&quot;border&quot;, &quot;solid&quot;)
        .unwrap();
    let context = canvas
        .get_context(&quot;2d&quot;)
        .unwrap()
        .unwrap()
        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
        .unwrap();
    let context = Rc::new(context);
    let pressed = Rc::new(Cell::new(false));
    {
        let context = context.clone();
        let pressed = pressed.clone();
        let closure: Closure&lt;FnMut(_)&gt; = Closure::new(move |event: web_sys::MouseEvent| {
            context.begin_path();
            context.move_to(event.offset_x() as f64, event.offset_y() as f64);
            pressed.set(true);
        });
        (canvas.as_ref() as &amp;web_sys::EventTarget)
            .add_event_listener_with_callback(&quot;mousedown&quot;, closure.as_ref().unchecked_ref())
            .unwrap();
        closure.forget();
    }
    {
        let context = context.clone();
        let pressed = pressed.clone();
        let closure: Closure&lt;FnMut(_)&gt; = Closure::new(move |event: web_sys::MouseEvent| {
            if pressed.get() {
                context.line_to(event.offset_x() as f64, event.offset_y() as f64);
                context.stroke();
                context.begin_path();
                context.move_to(event.offset_x() as f64, event.offset_y() as f64);
            }
        });
        (canvas.as_ref() as &amp;web_sys::EventTarget)
            .add_event_listener_with_callback(&quot;mousemove&quot;, closure.as_ref().unchecked_ref())
            .unwrap();
        closure.forget();
    }
    {
        let context = context.clone();
        let pressed = pressed.clone();
        let closure: Closure&lt;FnMut(_)&gt; = Closure::new(move |event: web_sys::MouseEvent| {
            pressed.set(false);
            context.line_to(event.offset_x() as f64, event.offset_y() as f64);
            context.stroke();
        });
        (canvas.as_ref() as &amp;web_sys::EventTarget)
            .add_event_listener_with_callback(&quot;mouseup&quot;, closure.as_ref().unchecked_ref())
            .unwrap();
        closure.forget();
    }
}

</code></pre></pre>
<a class="header" href="#reference" id="reference"><h1>Reference</h1></a>
<p>This section contains reference material for using <code>wasm-bindgen</code>. It is not
intended to be read start to finish. Instead, it aims to quickly answer
questions like:</p>
<ul>
<li>
<p>Is type X supported as a parameter in a Rust function exported to JavaScript?</p>
</li>
<li>
<p>What was that CLI flag to disable ECMAScript modules output, and instead
attach the JavaScript bindings directly to <code>window</code>?</p>
</li>
</ul>
<a class="header" href="#passing-rust-closures-to-imported-javascript-functions" id="passing-rust-closures-to-imported-javascript-functions"><h1>Passing Rust Closures to Imported JavaScript Functions</h1></a>
<p>The <code>#[wasm_bindgen]</code> attribute supports Rust closures being passed to
JavaScript in two variants:</p>
<ol>
<li>
<p>Stack-lifetime closures that should not be invoked by JavaScript again after
the imported JavaScript function that the closure was passed to returns.</p>
</li>
<li>
<p>Heap-allocated closures that can be invoked any number of times, but must be
explicitly deallocated when finished.</p>
</li>
</ol>
<a class="header" href="#stack-lifetime-closures" id="stack-lifetime-closures"><h2>Stack-Lifetime Closures</h2></a>
<p>Closures with a stack lifetime are passed to JavaScript as either <code>&amp;Fn</code> or <code>&amp;mut FnMut</code> trait objects:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Import JS functions that take closures

#[wasm_bindgen]
extern {
    fn takes_immutable_closure(f: &amp;Fn());

    fn takes_mutable_closure(f: &amp;mut FnMut());
}

// Usage

takes_immutable_closure(&amp;|| {
    // ...
});

let mut times_called = 0;
takes_mutable_closure(&amp;mut || {
    times_called += 1;
});
#}</code></pre></pre>
<p><strong>Once these imported functions return, the closures that were given to them
will become invalidated, and any future attempts to call those closures from
JavaScript will raise an exception.</strong></p>
<p>Closures also support arguments and return values like exports do, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn takes_closure_that_takes_int_and_returns_string(x: &amp;Fn(u32) -&gt; String);
}

takes_closure_that_takes_int_and_returns_string(&amp;|x: u32| -&gt; String {
    format!(&quot;x is {}&quot;, x)
});
#}</code></pre></pre>
<a class="header" href="#heap-allocated-closures" id="heap-allocated-closures"><h2>Heap-Allocated Closures</h2></a>
<p>Sometimes the discipline of stack-lifetime closures is not desired. For example,
you'd like to schedule a closure to be run on the next turn of the event loop in
JavaScript through <code>setTimeout</code>. For this, you want the imported function to
return but the JavaScript closure still needs to be valid!</p>
<p>For this scenario, you need the <code>Closure</code> type, which is defined in the
<code>wasm_bindgen</code> crate, exported in <code>wasm_bindgen::prelude</code>, and represents a
&quot;long lived&quot; closure.
The <code>Closure</code> type is currently behind a feature which needs to be enabled:</p>
<pre><code class="language-toml">[dependencies]
wasm-bindgen = {version = &quot;^0.2&quot;, features = [&quot;nightly&quot;]}
</code></pre>
<p>The validity of the JavaScript closure is tied to the lifetime of the <code>Closure</code>
in Rust. <strong>Once a <code>Closure</code> is dropped, it will deallocate its internal memory
and invalidate the corresponding JavaScript function so that any further
attempts to invoke it raise an exception.</strong></p>
<p>Like stack closures a <code>Closure</code> supports both <code>Fn</code> and <code>FnMut</code> closures, as well
as arguments and returns.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn setInterval(closure: &amp;Closure&lt;FnMut()&gt;, millis: u32) -&gt; f64;
    fn cancelInterval(token: f64);

    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[wasm_bindgen]
pub struct Interval {
    closure: Closure&lt;FnMut()&gt;,
    token: f64,
}

impl Interval {
    pub fn new&lt;F&gt;(millis: u32, f: F) -&gt; Interval
    where
        F: FnMut()
    {
        // Construct a new closure.
        let closure = Closure::new(f);

        // Pass the closuer to JS, to run every n milliseconds.
        let token = setInterval(&amp;closure, millis);

        Interval { closure, token }
    }
}

// When the Interval is destroyed, cancel its `setInterval` timer.
impl Drop for Interval {
    fn drop(&amp;mut self) {
        cancelInterval(self.token);
    }
}

// Keep logging &quot;hello&quot; every second until the resulting `Interval` is dropped.
#[wasm_bindgen]
pub fn hello() -&gt; Interval {
    Interval::new(1_000, || log(&quot;hello&quot;));
}
#}</code></pre></pre>
<a class="header" href="#receiving-javascript-closures-in-exported-rust-functions" id="receiving-javascript-closures-in-exported-rust-functions"><h1>Receiving JavaScript Closures in Exported Rust Functions</h1></a>
<p>You can use the <code>js-sys</code> crate to access JavaScript's <code>Function</code> type, and
invoke that function via <code>Function.prototype.apply</code> and
<code>Function.prototype.call</code>.</p>
<p>For example, we can wrap a <code>Vec&lt;u32&gt;</code> in a new type, export it to JavaScript,
and invoke a JavaScript closure on each member of the <code>Vec</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct VecU32 {
    xs: Vec&lt;u32&gt;,
}

#[wasm_bindgen]
impl VecU32 {
    pub fn each(&amp;self, f: &amp;js_sys::Function) {
        let this = JsValue::NULL;
        for x in &amp;self.xs {
            let x = JsValue::from(x);
            let _ = f.call1(&amp;this, &amp;x);
        }
    }
}
#}</code></pre></pre>
<p>Since Rust has no function overloading, the <code>call#</code> method also requires a
number representing the amount of arguments passed to the JavaScript closure.</p>
<a class="header" href="#converting-between-javascript-promises-and-rust-futures" id="converting-between-javascript-promises-and-rust-futures"><h1>Converting Between JavaScript <code>Promise</code>s and Rust <code>Future</code>s</h1></a>
<p>The <code>wasm-bindgen-futures</code> crate bridges the gap between JavaScript <code>Promise</code>s
and Rust <code>Future</code>s. Its <code>JsFuture</code> type provides conversion from a JavaScript
<code>Promise</code> into a Rust <code>Future</code>, and its <code>future_to_promise</code> function converts a
Rust <code>Future</code> into a JavaScript <code>Promise</code> and schedules it to be driven to
completion.</p>
<p>Learn more:</p>
<ul>
<li><a href="https://crates.io/crates/wasm-bindgen-futures"><code>wasm_bindgen_futures</code> on crates.io</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/"><code>wasm-bindgen-futures</code> API documentation and example usage</a></li>
</ul>
<a class="header" href="#iterating-over-javascript-values" id="iterating-over-javascript-values"><h1>Iterating over JavaScript Values</h1></a>
<a class="header" href="#methods-that-return-js_sysiterator" id="methods-that-return-js_sysiterator"><h2>Methods That Return <code>js_sys::Iterator</code></h2></a>
<p>Some JavaScript collections have methods for iterating over their values or
keys:</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Map.html#method.values"><code>Map::values</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Set.html#method.keys"><code>Set::keys</code></a></li>
<li>etc...</li>
</ul>
<p>These methods return
<a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Iterator.html"><code>js_sys::Iterator</code></a>,
which is the Rust representation of a JavaScript object that has a <code>next</code> method
that either returns the next item in the iteration, notes that iteration has
completed, or throws an error. That is, <code>js_sys::Iterator</code> represents an object
that implements <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">the duck-typed JavaScript iteration
protocol</a>.</p>
<p><code>js_sys::Iterator</code> can be converted into a Rust iterator either by reference
(into
<a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Iter.html"><code>js_sys::Iter&lt;'a&gt;</code></a>)
or by value (into
<a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.IntoIter.html"><code>js_sys::IntoIter</code></a>). The
Rust iterator will yield items of type <code>Result&lt;JsValue&gt;</code>. If it yields an
<code>Ok(...)</code>, then the JS iterator protocol returned an element. If it yields an
<code>Err(...)</code>, then the JS iterator protocol threw an exception.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn count_strings_in_set(set: &amp;js_sys::Set) -&gt; u32 {
    let mut count = 0;

    // Call `keys` to get an iterator over the set's elements. Because this is
    // in a `for ... in ...` loop, Rust will automatically call its
    // `IntoIterator` trait implementation to convert it into a Rust iterator.
    for x in set.keys() {
        // We know the built-in iterator for set elements won't throw
        // exceptions, so just unwrap the element. If this was an untrusted
        // iterator, we might want to explicitly handle the case where it throws
        // an exception instead of returning a `{ value, done }` object.
        let x = x.unwrap();

        // If `x` is a string, increment our count of strings in the set!
        if x.is_string() {
            count += 1;
        }
    }

    count
}
#}</code></pre></pre>
<a class="header" href="#iterating-over-uanyu-javascript-object-that-implements-the-iterator-protocol" id="iterating-over-uanyu-javascript-object-that-implements-the-iterator-protocol"><h2>Iterating Over <u>Any</u> JavaScript Object that Implements the Iterator Protocol</h2></a>
<p>You could manually test for whether an object implements JS's duck-typed
iterator protocol, and if so, convert it into a <code>js_sys::Iterator</code> that you can
finally iterate over. You don't need to do this by-hand, however, since we
bundled this up as <a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/fn.try_iter.html">the <code>js_sys::try_iter</code>
function!</a></p>
<p>For example, we can write a function that collects the numbers from any JS
iterable and returns them as an <code>Array</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn collect_numbers(some_iterable: &amp;JsValue) -&gt; Result&lt;js_sys::Array, JsValue&gt; {
    let nums = js_sys::Array::new();

    let iterator = match js_sys::try_iter(some_iterable)?.ok_or_else(|| {
        &quot;need to pass iterable JS values!&quot;.into()
    })?;

    for x in iterator {
        // If the iterator's `next` method throws an error, propagate it
        // up to the caller.
        let x = x?;

        // If `x` is a number, add it to our array of numbers!
        if x.is_f64() {
            nums.push(&amp;x);
        }
    }

    Ok(nums)
}
#}</code></pre></pre>
<a class="header" href="#no-es-modules" id="no-es-modules"><h1>No ES Modules</h1></a>
<p>Explained a bit more in the <a href="design.html">internal design</a> section one of the
key foundational principles of <code>wasm-bindgen</code> is ES modules. It supports working
without ES modules, however! Not all JS tooling and browsers are ready for ES
modules by default, so it can sometimes be helpful to quickly get up and running
without them to kick the tires and see how <code>wasm-bindgen</code> works.</p>
<p>Let's start out with our hello-world example from previous chapters, and you can
also <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/no_modules">follow along in the repository</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn alert(msg: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) -&gt; String {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name);
}
#}</code></pre></pre>
<p>Like usual, we first compile this to wasm:</p>
<pre><code>$ cargo build --target wasm32-unknown-unknown
</code></pre>
<p>Next, to avoid using ES modules, pass the <code>--no-modules</code> option to the
<code>wasm-bindgen</code> command:</p>
<pre><code>$ wasm-bindgen target/wasm32-unknown-unknown/debug/hello.wasm --no-modules --out-dir .
</code></pre>
<p>Next up we need to write some HTML to interact with the wasm:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;script src='./hello.js'&gt;&lt;/script&gt;
    &lt;script&gt;
      wasm_bindgen('./hello_bg.wasm')
        .then(() =&gt; wasm_bindgen.greet('World'));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and that's it! If you open up that web page in a browser (needs to be over HTTP)
then you should see an alert for &quot;Hello, World!&quot;.</p>
<p>The <code>--no-modules</code> output will not instantiate or compile the wasm module when
included on a web page, instead it just parses and configures the JS bindings
for the wasm-module-to-be. The page is configured with one exported global, in
this case <code>wasm_bindgen</code>. The name of this global can be configured with the
<code>--no-modules-global</code> option.</p>
<p>The global <code>wasm_bindgen</code> is a function that takes one argument, the path to the
wasm file. When invoked <code>wasm_bindgen</code> will return a promise for when the wasm
file is ready-to-go. After that all exported functionality on
<code>wasm_bindgen</code> will be functional.</p>
<p>In the example above, after calling <code>wasm_bindgen('./hello_bg.wasm')</code> we wait
for the wasm module to be compiled, and afterwards we're invoking our <code>greet</code>
export.</p>
<p>Note that exports are available for binding before the wasm module has been
instantiated, for example this would have also worked:</p>
<pre><code class="language-js">const { greet } = wasm_bindgen;

wasm_bindgen('./hello_bg.wasm')
  .then(() =&gt; greet('World'));
</code></pre>
<a class="header" href="#serializing-and-deserializing-arbitrary-data-into-and-from-jsvalue-with-serde" id="serializing-and-deserializing-arbitrary-data-into-and-from-jsvalue-with-serde"><h1>Serializing and Deserializing Arbitrary Data Into and From <code>JsValue</code> with Serde</h1></a>
<p>It's possible to pass arbirtrary data from Rust to JavaScript by serializing it
with <a href="https://github.com/serde-rs/serde">Serde</a>. <code>wasm-bindgen</code> includes the
<code>JsValue</code> type, which streamlines serializing and deserializing.</p>
<a class="header" href="#enable-the-serde-serialize-feature" id="enable-the-serde-serialize-feature"><h2>Enable the <code>&quot;serde-serialize&quot;</code> Feature</h2></a>
<p>To enable the <code>&quot;serde-serialize&quot;</code> feature, do two things in <code>Cargo.toml</code>:</p>
<ol>
<li>Add the <code>serde</code> and <code>serde_derive</code> crates to <code>[dependencies]</code>.</li>
<li>Add <code>features = [&quot;serde-serialize&quot;]</code> to the existing <code>wasm-bindgen</code>
dependency.</li>
</ol>
<pre><code class="language-toml">[dependencies]
serde = &quot;^1.0.59&quot;
serde_derive = &quot;^1.0.59&quot;

[dependencies.wasm-bindgen]
version = &quot;^0.2&quot;
features = [&quot;serde-serialize&quot;]
</code></pre>
<a class="header" href="#import-serdes-custom-derive-macros" id="import-serdes-custom-derive-macros"><h2>Import Serde's Custom-Derive Macros</h2></a>
<p>In your top-level Rust file (e.g. <code>lib.rs</code> or <code>main.rs</code>), enable the <code>Serialize</code>
and <code>Deserialize</code> custom-derive macros:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate serde_derive;
#}</code></pre></pre>
<a class="header" href="#derive-the-serialize-and-deserialize-traits" id="derive-the-serialize-and-deserialize-traits"><h2>Derive the <code>Serialize</code> and <code>Deserialize</code> Traits</h2></a>
<p>Add <code>#![derive(Serialize, Deserialize)]</code> to your type. All of your type's
members must also be supported by Serde, i.e. their types must also implement
the <code>Serialize</code> and <code>Deserialize</code> traits.</p>
<p>For example, let's say we'd like to pass this <code>struct</code> to JavaScript; doing so
is not possible in <code>wasm-bindgen</code> normally due to the use of <code>HashMap</code>s, arrays,
and nested <code>Vec</code>s. None of those types are supported for sending across the wasm
ABI naively, but all of them implement Serde's <code>Serialize</code> and <code>Deserialize</code>.</p>
<p>Note that we do not need to use the <code>#[wasm_bindgen]</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Serialize)]
pub struct Example {
    pub field1: HashMap&lt;u32, String&gt;,
    pub field2: Vec&lt;Vec&lt;f32&gt;&gt;,
    pub field3: [f32; 4],
}
#}</code></pre></pre>
<a class="header" href="#send-it-to-javascript-with-jsvaluefrom_serde" id="send-it-to-javascript-with-jsvaluefrom_serde"><h2>Send it to JavaScript with <code>JsValue::from_serde</code></h2></a>
<p>Here's a function that will pass an <code>Example</code> to JavaScript by serializing it to
<code>JsValue</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn send_example_to_js() -&gt; JsValue {
    let mut field1 = HashMap::new();
    field1.insert(0, String::from(&quot;ex&quot;));
    let example = Example {
        field1,
        field2: vec![vec![1., 2.], vec![3., 4.]],
        field3: [1., 2., 3., 4.]
    };

    JsValue::from_serde(&amp;example).unwrap()
}
#}</code></pre></pre>
<a class="header" href="#receive-it-from-javascript-with-jsvalueinto_serde" id="receive-it-from-javascript-with-jsvalueinto_serde"><h2>Receive it from JavaScript with <code>JsValue::into_serde</code></h2></a>
<p>Here's a function that will receive a <code>JsValue</code> parameter from JavaScript and
then deserialize an <code>Example</code> from it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn receive_example_from_js(val: &amp;JsValue) {
    let example: Example = val.into_serde().unwrap();
    ...
}
#}</code></pre></pre>
<a class="header" href="#javascript-usage" id="javascript-usage"><h2>JavaScript Usage</h2></a>
<p>In the <code>JsValue</code> that JavaScript gets, <code>field1</code> will be an <code>Object</code> (not a
JavaScript <code>Map</code>), <code>field2</code> will be a JavaScript <code>Array</code> whose members are
<code>Array</code>s of numbers, and <code>field3</code> will be an <code>Array</code> of numbers.</p>
<pre><code class="language-js">import { send_example_to_js, receive_example_from_js } from &quot;example&quot;;

// Get the example object from wasm.
let example = send_example_to_js();

// Add another &quot;Vec&quot; element to the end of the &quot;Vec&lt;Vec&lt;f32&gt;&gt;&quot;
example.field2.push([5,6]);

// Send the example object back to wasm.
receive_example_from_js(example);
</code></pre>
<a class="header" href="#accessing-properties-of-untyped-javascript-values" id="accessing-properties-of-untyped-javascript-values"><h1>Accessing Properties of Untyped JavaScript Values</h1></a>
<p>To read and write arbitrary properties from any untyped JavaScript value
regardless if it is an <code>instanceof</code> some JavaScript class or not, use <a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Reflect.html">the
<code>js_sys::Reflect</code> APIs</a>. These APIs are bindings to the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">JavaScript builtin <code>Reflect</code> object</a> and its methods.</p>
<p>You might also benefit from <a href="./working-with-duck-typed-interfaces.html">using duck-typed
interfaces</a> instead of working with
untyped values.</p>
<a class="header" href="#reading-properties-with-js_sysreflectget" id="reading-properties-with-js_sysreflectget"><h2>Reading Properties with <code>js_sys::Reflect::get</code></h2></a>
<p><a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Reflect.html#method.get">API documentation for <code>js_sys::Reflect::get</code>.</a></p>
<p>A function that returns the value of a property.</p>
<a class="header" href="#rust-usage" id="rust-usage"><h4>Rust Usage</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let value = js_sys::Reflect::get(&amp;target, &amp;property_key)?;
#}</code></pre></pre>
<a class="header" href="#javascript-equivalent" id="javascript-equivalent"><h4>JavaScript Equivalent</h4></a>
<pre><code class="language-js">let value = target[property_key];
</code></pre>
<a class="header" href="#writing-properties-with-js_sysreflectset" id="writing-properties-with-js_sysreflectset"><h2>Writing Properties with <code>js_sys::Reflect::set</code></h2></a>
<p><a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Reflect.html#method.set">API documentation for <code>js_sys::Reflect::set</code>.</a></p>
<p>A function that assigns a value to a property. Returns a boolean that is true if
the update was successful.</p>
<a class="header" href="#rust-usage-1" id="rust-usage-1"><h4>Rust Usage</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
js_sys::Reflect::set(&amp;target, &amp;property_key, &amp;value)?;
#}</code></pre></pre>
<a class="header" href="#javascript-equivalent-1" id="javascript-equivalent-1"><h4>JavaScript Equivalent</h4></a>
<pre><code class="language-js">target[property_key] = value;
</code></pre>
<a class="header" href="#determining-if-a-property-exists-with-js_sysreflecthas" id="determining-if-a-property-exists-with-js_sysreflecthas"><h2>Determining if a Property Exists with <code>js_sys::Reflect::has</code></h2></a>
<p><a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Reflect.html#method.has">API documentation for <code>js_sys::Reflect::has</code>.</a></p>
<p>The JavaScript <code>in</code> operator as function. Returns a boolean indicating whether
an own or inherited property exists on the target.</p>
<a class="header" href="#rust-usage-2" id="rust-usage-2"><h4>Rust Usage</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if js_sys::Reflect::has(&amp;target, &amp;property_key)? {
    // ...
} else {
    // ...
}
#}</code></pre></pre>
<a class="header" href="#javascript-equivalent-2" id="javascript-equivalent-2"><h4>JavaScript Equivalent</h4></a>
<pre><code class="language-js">if (property_key in target) {
    // ...
} else {
    // ...
}
</code></pre>
<a class="header" href="#but-wait--theres-more" id="but-wait--theres-more"><h2>But wait — there's more!</h2></a>
<p>See <a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Reflect.html">the <code>js_sys::Reflect</code> API documentation</a> for the full
listing of JavaScript value reflection and introspection capabilities.</p>
<a class="header" href="#working-with-duck-typed-interfaces" id="working-with-duck-typed-interfaces"><h1>Working with Duck-Typed Interfaces</h1></a>
<p>Liberal use of <a href="./attributes/on-js-imports/structural.html">the <code>structural</code>
attribute</a> on imported methods,
getters, and setters allows you to define duck-typed interfaces. A duck-typed
interface is one where many different JavaScript objects that don't share the
same base class in their prototype chain and therefore are not <code>instanceof</code> the
same base can be used the same way.</p>
<a class="header" href="#defining-a-duck-typed-interface-in-rust" id="defining-a-duck-typed-interface-in-rust"><h2>Defining a Duck-Typed Interface in Rust</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

/// Here is a duck-typed interface for any JavaScript object that has a `quack`
/// method.
///
/// Note that any attempts to check if an object is a `Quacks` with
/// `JsCast::is_instance_of` (i.e. the `instanceof` operator) will fail because
/// there is no JS class named `Quacks`.
#[wasm_bindgen]
extern {
    pub type Quacks;

    #[wasm_bindgen(structural, method)]
    pub fn quack(this: &amp;Quacks) -&gt; String;
}

/// Next, we can export a function that takes any object that quacks:
#[wasm_bindgen]
pub fn make_em_quack_to_this(duck: &amp;Quacks) {
    let s = duck.quack();
    // ...
}

#}</code></pre></pre>
<a class="header" href="#javascript-usage-1" id="javascript-usage-1"><h2>JavaScript Usage</h2></a>
<pre><code class="language-js">import { make_em_quack_to_this } from &quot;./rust_duck_typed_interfaces&quot;;

// All of these objects implement the `Quacks` interface!

const alex = {
  quack: () =&gt; &quot;you're not wrong...&quot;
};

const ashley = {
  quack: () =&gt; &quot;&lt;corgi.gif&gt;&quot;
};

const nick = {
  quack: () =&gt; &quot;rappers I monkey-flip em with the funky rhythm I be kickin&quot;
};

// Get all our ducks in a row and call into wasm!

make_em_quack_to_this(alex);
make_em_quack_to_this(ashley);
make_em_quack_to_this(nick);

</code></pre>
<a class="header" href="#the-wasm-bindgen-command-line-interface" id="the-wasm-bindgen-command-line-interface"><h1>The <code>wasm-bindgen</code> Command Line Interface</h1></a>
<p>The <code>wasm-bindgen</code> command line tool has a number of options available to it to
tweak the JavaScript that is generated. The most up-to-date set of flags can
always be listed via <code>wasm-bindgen --help</code>.</p>
<blockquote>
<p>Note: usually, one should use a <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code>-based workflow</a> rather
than running the <code>wasm-bindgen</code> command line tool by hand.</p>
</blockquote>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<pre><code>wasm-bindgen [options] ./target/wasm32-unknown-unknown/release/crate.wasm
</code></pre>
<a class="header" href="#options" id="options"><h2>Options</h2></a>
<a class="header" href="#a--out-dir-dir" id="a--out-dir-dir"><h3><code>--out-dir DIR</code></h3></a>
<p>The target directory to emit the JavaScript bindings, TypeScript definitions,
processed <code>.wasm</code> binary, etc...</p>
<a class="header" href="#a--nodejs" id="a--nodejs"><h3><code>--nodejs</code></h3></a>
<p>This flag will tailor output for Node instead of browsers, allowing for native
usage of <code>require</code> of the generated JS and internally using <code>require</code> instead of
ECMAScript modules. When using this flag no further postprocessing (aka a
bundler) should be necessary to work with the wasm.</p>
<a class="header" href="#a--browser" id="a--browser"><h3><code>--browser</code></h3></a>
<p>This flag will tailor the output specifically for browsers, making it
incompatible with Node. This will basically make the generated JS a tiny bit
smaller as runtime checks for Node won't be necessary.</p>
<a class="header" href="#a--no-modules-and----no-modules-global-var" id="a--no-modules-and----no-modules-global-var"><h3><code>--no-modules</code> and  <code>--no-modules-global VAR</code></h3></a>
<p>The default output of <code>wasm-bindgen</code> uses ECMAScript modules. These options
indicate that ECMAScript modules should <em>not</em> be used, and that output should be
tailored for a properties on the JavaScript global object (e.g. <code>window</code>).</p>
<p>The <code>--no-modules-global VAR</code> option makes <code>VAR</code> the global property that the
JavaScript bindings are attached to.</p>
<p>More information can be found in the <a href="./no-esm.html">documentation for building without
ECMAScript modules</a>.</p>
<a class="header" href="#a--typescript" id="a--typescript"><h3><code>--typescript</code></h3></a>
<p>Output a TypeScript declaration file for the generated JavaScript bindings. This
is on by default.</p>
<a class="header" href="#a--no-typescript" id="a--no-typescript"><h3><code>--no-typescript</code></h3></a>
<p>By default, a <code>*.d.ts</code> TypeScript declaration file is generated for the
generated JavaScript bindings, but this flag will disable that.</p>
<a class="header" href="#a--debug" id="a--debug"><h3><code>--debug</code></h3></a>
<p>Generates a bit more JS and wasm in &quot;debug mode&quot; to help catch programmer
errors, but this output isn't intended to be shipped to production.</p>
<a class="header" href="#a--no-demangle" id="a--no-demangle"><h3><code>--no-demangle</code></h3></a>
<p>When post-processing the <code>.wasm</code> binary, do not demangle Rust symbols in the
&quot;names&quot; custom section.</p>
<a class="header" href="#a--keep-debug" id="a--keep-debug"><h3><code>--keep-debug</code></h3></a>
<p>When post-processing the <code>.wasm</code> binary, do not strip DWARF debug info custom
sections.</p>
<a class="header" href="#optimizing-for-size-with-wasm-bindgen" id="optimizing-for-size-with-wasm-bindgen"><h1>Optimizing for Size with <code>wasm-bindgen</code></h1></a>
<p>The Rust and WebAssembly Working Group's <a href="https://rustwasm.github.io/book/game-of-life/introduction.html">Game of Life tutorial</a> has an
excellent section on <a href="https://rustwasm.github.io/book/game-of-life/code-size.html">shrinking wasm code size</a>, but there's a few
<code>wasm-bindgen</code>-specific items to mention as well!</p>
<p>First and foremost, <code>wasm-bindgen</code> is designed to be lightweight and a &quot;pay only
for what you use&quot; mentality. If you suspect that <code>wasm-bindgen</code> is bloating your
program that is a bug and we'd like to know about it! Please feel free to <a href="https://github.com/rustwasm/wasm-bindgen/issues/new">file
an issue</a>, even if it's a question!</p>
<a class="header" href="#what-to-profile" id="what-to-profile"><h3>What to profile</h3></a>
<p>With <code>wasm-bindgen</code> there's a few different files to be measuring the size of.
The first of which is the output of the compiler itself, typically at
<code>target/wasm32-unknown-unknown/release/foo.wasm</code>. <strong>This file is not optimized
for size and you should not measure it.</strong> The output of the compiler when
linking with <code>wasm-bindgen</code> is by design larger than it needs to be, the
<code>wasm-bindgen</code> CLI tool will automatically strip all unneeded functionality out
of the binary.</p>
<p>This leaves us with two primary generated files to measure the size of:</p>
<ul>
<li>
<p><strong>Generated wasm</strong> - after running the <code>wasm-bindgen</code> CLI tool you'll get a
file in <code>--out-dir</code> that looks like <code>foo_bg.wasm</code>. This file is the final
fully-finished artifact from <code>wasm-bindgen</code>, and it reflects the size of the
app you'll be publishing. All the optimizations <a href="https://rustwasm.github.io/book/game-of-life/code-size.html">mentioned in the code size
tutorial</a> will help reduce the size of this binary, so feel free to go
crazy!</p>
</li>
<li>
<p><strong>Generated JS</strong> - the other file after running <code>wasm-bindgen</code> is a <code>foo.js</code>
file which is what's actually imported by other JS code. This file is already
generated to be as small as possible (not including unneeded functionality).
The JS, however, is not uglified or minified, but rather still human readable
and debuggable. It's expected that you'll run an uglifier or bundler of the JS
output to minimize it further in your application. If you spot a way we could
reduce the output JS size further (or make it more amenable to bundler
minification), please let us know!</p>
</li>
</ul>
<a class="header" href="#example" id="example"><h3>Example</h3></a>
<p>As an example, the <code>wasm-bindgen</code> repository <a href="https://rustwasm.github.io/wasm-bindgen/examples/add.html">contains an example</a>
about generating small wasm binaries and shows off how to generate a small wasm
file for adding two numbers.</p>
<a class="header" href="#supported-rust-types-and-their-javascript-representations" id="supported-rust-types-and-their-javascript-representations"><h1>Supported Rust Types and their JavaScript Representations</h1></a>
<p>This section provides an overview of all the types that <code>wasm-bindgen</code> can send
and receive across the WebAssembly ABI boundary, and how they translate into
JavaScript.</p>
<a class="header" href="#imported-extern-whatever-javascript-types" id="imported-extern-whatever-javascript-types"><h1>Imported <code>extern Whatever;</code> JavaScript Types</h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Instances of the extant <code>Whatever</code> JavaScript class / prototype constructor </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage" id="example-rust-usage"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    pub type SomeJsType;
}

#[wasm_bindgen]
pub fn imported_type_by_value(x: SomeJsType) { /* ... */ }

#[wasm_bindgen]
pub fn imported_type_by_shared_ref(x: &amp;SomeJsType) { /* ... */ }

#[wasm_bindgen]
pub fn return_imported_type() -&gt; SomeJsType {
    unimplemented!()
}

#[wasm_bindgen]
pub fn take_option_imported_type(x: Option&lt;SomeJsType&gt;) { /* ... */ }

#[wasm_bindgen]
pub fn return_option_imported_type() -&gt; Option&lt;SomeJsType&gt; {
    unimplemented!()
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage" id="example-javascript-usage"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  imported_type_by_value,
  imported_type_by_shared_ref,
  return_imported_type,
  take_option_imported_type,
  return_option_imported_type,
} from './guide_supported_types_examples';

imported_type_by_value(new SomeJsType());
imported_type_by_shared_ref(new SomeJsType());

let x = return_imported_type();
console.log(x instanceof SomeJsType); // true

take_option_imported_type(null);
take_option_imported_type(undefined);
take_option_imported_type(new SomeJsType());

let y = return_option_imported_type();
if (y == null) {
  // ...
} else {
  console.log(y instanceof SomeJsType); // true
}

</code></pre>
<a class="header" href="#exported-struct-whatever-rust-types" id="exported-struct-whatever-rust-types"><h1>Exported <code>struct Whatever</code> Rust Types</h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Instances of a <code>wasm-bindgen</code>-generated JavaScript <code>class Whatever { ... }</code> </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-1" id="example-rust-usage-1"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct ExportedRustType {
    inner: u32,
}

#[wasm_bindgen]
pub fn exported_type_by_value(x: ExportedRustType) {}

#[wasm_bindgen]
pub fn exported_type_by_shared_ref(x: &amp;ExportedRustType) {}

#[wasm_bindgen]
pub fn exported_type_by_exclusive_ref(x: &amp;mut ExportedRustType) {}

#[wasm_bindgen]
pub fn return_exported_type() -&gt; ExportedRustType {
    unimplemented!()
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-1" id="example-javascript-usage-1"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  ExportedRustType,
  exported_type_by_value,
  exported_type_by_shared_ref,
  exported_type_by_exclusive_ref,
  return_exported_type,
} from './guide_supported_types_examples';

let rustThing = return_exported_type();
console.log(rustThing instanceof ExportedRustType); // true

exported_type_by_value(rustThing);
exported_type_by_shared_ref(rustThing);
exported_type_by_exclusive_ref(rustThing);

</code></pre>
<a class="header" href="#jsvalue" id="jsvalue"><h1><code>JsValue</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Any JavaScript value </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-2" id="example-rust-usage-2"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_js_value_by_value(x: JsValue) {}

#[wasm_bindgen]
pub fn take_js_value_by_shared_ref(x: &amp;JsValue) {}

#[wasm_bindgen]
pub fn return_js_value() -&gt; JsValue {
    JsValue::NULL
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-2" id="example-javascript-usage-2"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_js_value_by_value,
  take_js_value_by_shared_ref,
  return_js_value,
} from './guide_supported_types_examples';

take_js_value_by_value(42);
take_js_value_by_shared_ref('hello');

let v = return_js_value();

</code></pre>
<a class="header" href="#boxjsvalue" id="boxjsvalue"><h1><code>Box&lt;[JsValue]&gt;</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> A JavaScript <code>Array</code> object </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-3" id="example-rust-usage-3"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_boxed_js_value_slice_by_value(x: Box&lt;[JsValue]&gt;) {}

#[wasm_bindgen]
pub fn return_boxed_js_value_slice() -&gt; Box&lt;[JsValue]&gt; {
    vec![JsValue::NULL, JsValue::UNDEFINED].into_boxed_slice()
}

#[wasm_bindgen]
pub fn take_option_boxed_js_value_slice(x: Option&lt;Box&lt;[JsValue]&gt;&gt;) {}

#[wasm_bindgen]
pub fn return_option_boxed_js_value_slice() -&gt; Option&lt;Box&lt;[JsValue]&gt;&gt; {
    None
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-3" id="example-javascript-usage-3"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_boxed_js_value_slice_by_value,
  return_boxed_js_value_slice,
  take_option_boxed_js_value_slice,
  return_option_boxed_js_value_slice,
} from './guide_supported_types_examples';

take_boxed_js_value_slice_by_value([null, true, 2, {}, []]);

let values = return_boxed_js_value_slice();
console.log(values instanceof Array); // true

take_option_boxed_js_value_slice(null);
take_option_boxed_js_value_slice(undefined);
take_option_boxed_js_value_slice([1, 2, 3]);

let maybeValues = return_option_boxed_js_value_slice();
if (maybeValues == null) {
  // ...
} else {
  console.log(maybeValues instanceof Array); // true
}

</code></pre>
<a class="header" href="#const-t-and-mut-t" id="const-t-and-mut-t"><h1><code>*const T</code> and <code>*mut T</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> A JavaScript number value </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-4" id="example-rust-usage-4"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ptr;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_pointer_by_value(x: *mut u8) {}

#[wasm_bindgen]
pub fn return_pointer() -&gt; *mut u8 {
    ptr::null_mut()
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-4" id="example-javascript-usage-4"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_pointer_by_value,
  return_pointer,
} from './guide_supported_types_examples';
import { memory } from './guide_supported_types_examples_bg';

let ptr = return_pointer();
let buf = new Uint8Array(memory.buffer);
let value = buf[ptr];
console.log(`The byte at the ${ptr} address is ${value}`);

take_pointer_by_value(ptr);

</code></pre>
<a class="header" href="#numbers-u8-i8-u16-i16-u32-i32-u64-i64-isize-usize-f32-and-f64" id="numbers-u8-i8-u16-i16-u32-i32-u64-i64-isize-usize-f32-and-f64"><h1>Numbers: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>isize</code>, <code>usize</code>, <code>f32</code>, and <code>f64</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> A JavaScript number value </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-5" id="example-rust-usage-5"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_number_by_value(x: u32) {}

#[wasm_bindgen]
pub fn return_number() -&gt; f64 {
    42.0
}

#[wasm_bindgen]
pub fn take_option_number(x: Option&lt;u8&gt;) {}

#[wasm_bindgen]
pub fn return_option_number() -&gt; Option&lt;i16&gt; {
    Some(-300)
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-5" id="example-javascript-usage-5"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_number_by_value,
  return_number,
  take_option_number,
  return_option_number,
} from './guide_supported_types_examples';

take_number_by_value(42);

let x = return_number();
console.log(typeof x); // &quot;number&quot;

take_option_number(null);
take_option_number(undefined);
take_option_number(13);

let y = return_option_number();
if (y == null) {
  // ...
} else {
  console.log(typeof y); // &quot;number&quot;
}

</code></pre>
<a class="header" href="#bool" id="bool"><h1><code>bool</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> A JavaScript boolean value </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-6" id="example-rust-usage-6"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_bool_by_value(x: bool) {}

#[wasm_bindgen]
pub fn return_bool() -&gt; bool {
    true
}

#[wasm_bindgen]
pub fn take_option_bool(x: Option&lt;bool&gt;) {}

#[wasm_bindgen]
pub fn return_option_bool() -&gt; Option&lt;bool&gt; {
    Some(false)
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-6" id="example-javascript-usage-6"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_char_by_value,
  return_char,
  take_option_bool,
  return_option_bool,
} from './guide_supported_types_examples';

take_bool_by_value(true);

let b = return_bool();
console.log(typeof b); // &quot;boolean&quot;

take_option_bool(null);
take_option_bool(undefined);
take_option_bool(true);

let c = return_option_bool();
if (c == null) {
  // ...
} else {
  console.log(typeof c); // &quot;boolean&quot;
}

</code></pre>
<a class="header" href="#char" id="char"><h1><code>char</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> A JavaScript string value </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-7" id="example-rust-usage-7"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_char_by_value(x: char) {}

#[wasm_bindgen]
pub fn return_char() -&gt; char {
    '🚀'
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-7" id="example-javascript-usage-7"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_char_by_value,
  return_char,
} from './guide_supported_types_examples';

take_char_by_value('a');

let c = return_char();
console.log(typeof c); // &quot;string&quot;

</code></pre>
<a class="header" href="#str" id="str"><h1><code>str</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> No </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> JavaScript string value </td></tr>
</tbody></table>
<p>Copies the string's contents back and forth between the JavaScript
garbage-collected heap and the Wasm linear memory with <code>TextDecoder</code> and
<code>TextEncoder</code>. If you don't want to perform this copy, and would rather work
with handles to JavaScript string values, use the <code>js_sys::JsString</code> type.</p>
<a class="header" href="#example-rust-usage-8" id="example-rust-usage-8"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_str_by_shared_ref(x: &amp;str) {}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-8" id="example-javascript-usage-8"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_str_by_shared_ref,
} from './guide_supported_types_examples';

take_str_by_shared_ref('hello');

</code></pre>
<a class="header" href="#string" id="string"><h1><code>String</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> JavaScript string value </td></tr>
</tbody></table>
<p>Copies the string's contents back and forth between the JavaScript
garbage-collected heap and the Wasm linear memory with <code>TextDecoder</code> and
<code>TextEncoder</code></p>
<a class="header" href="#example-rust-usage-9" id="example-rust-usage-9"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_string_by_value(x: String) {}

#[wasm_bindgen]
pub fn return_string() -&gt; String {
    &quot;hello&quot;.into()
}

#[wasm_bindgen]
pub fn take_option_string(x: Option&lt;String&gt;) {}

#[wasm_bindgen]
pub fn return_option_string() -&gt; Option&lt;String&gt; {
    None
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-9" id="example-javascript-usage-9"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_string_by_value,
  return_string,
  take_option_string,
  return_option_string,
} from './guide_supported_types_examples';

take_string_by_value('hello');

let s = return_string();
console.log(typeof s); // &quot;string&quot;

take_option_string(null);
take_option_string(undefined);
take_option_string('hello');

let t = return_option_string();
if (t == null) {
  // ...
} else {
  console.log(typeof s); // &quot;string&quot;
}

</code></pre>
<a class="header" href="#number-slices-u8-i8-u16-i16-u32-i32-u64-i64-f32-and-f64" id="number-slices-u8-i8-u16-i16-u32-i32-u64-i64-f32-and-f64"><h1>Number Slices: <code>[u8]</code>, <code>[i8]</code>, <code>[u16]</code>, <code>[i16]</code>, <code>[u32]</code>, <code>[i32]</code>, <code>[u64]</code>, <code>[i64]</code>, <code>[f32]</code>, and <code>[f64]</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;&amp;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> A JavaScript <code>TypedArray</code> view of the Wasm memory for the boxed slice of the appropriate type (<code>Int32Array</code>, <code>Uint8Array</code>, etc) </td></tr>
</tbody></table>
<a class="header" href="#example-rust-usage-10" id="example-rust-usage-10"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_number_slice_by_shared_ref(x: &amp;[f64]) {}

#[wasm_bindgen]
pub fn take_number_slice_by_exclusive_ref(x: &amp;mut [u8]) {}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-10" id="example-javascript-usage-10"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_number_slice_by_value,
  return_number_slice,
  take_option_number_slice,
  return_option_number_slice,
} from './guide_supported_types_examples';

take_number_slice_by_shared_ref(new Float64Array(100));
take_number_slice_by_exclusive_ref(new Uint8Array(100));

</code></pre>
<a class="header" href="#boxed-number-slices-boxu8-boxi8-boxu16-boxi16-boxu32-boxi32-boxu64-boxi64-boxf32-and-boxf64" id="boxed-number-slices-boxu8-boxi8-boxu16-boxi16-boxu32-boxi32-boxu64-boxi64-boxf32-and-boxf64"><h1>Boxed Number Slices: <code>Box&lt;[u8]&gt;</code>, <code>Box&lt;[i8]&gt;</code>, <code>Box&lt;[u16]&gt;</code>, <code>Box&lt;[i16]&gt;</code>, <code>Box&lt;[u32]&gt;</code>, <code>Box&lt;[i32]&gt;</code>, <code>Box&lt;[u64]&gt;</code>, <code>Box&lt;[i64]&gt;</code>, <code>Box&lt;[f32]&gt;</code>, and <code>Box&lt;[f64]&gt;</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> A JavaScript <code>TypedArray</code> of the appropriate type (<code>Int32Array</code>, <code>Uint8Array</code>, etc...) </td></tr>
</tbody></table>
<p>Note that the contents of the slice are copied into the JavaScript <code>TypedArray</code>
from the Wasm linear memory when returning a boxed slice to JavaScript, and vice
versa when receiving a JavaScript <code>TypedArray</code> as a boxed slice in Rust.</p>
<a class="header" href="#example-rust-usage-11" id="example-rust-usage-11"><h2>Example Rust Usage</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn take_boxed_number_slice_by_value(x: Box&lt;[f64]&gt;) {}

#[wasm_bindgen]
pub fn return_boxed_number_slice() -&gt; Box&lt;[u32]&gt; {
    (0..42).collect::&lt;Vec&lt;u32&gt;&gt;().into_boxed_slice()
}

#[wasm_bindgen]
pub fn take_option_boxed_number_slice(x: Option&lt;Box&lt;[u8]&gt;&gt;) {}

#[wasm_bindgen]
pub fn return_option_boxed_number_slice() -&gt; Option&lt;Box&lt;[i32]&gt;&gt; {
    None
}

#}</code></pre></pre>
<a class="header" href="#example-javascript-usage-11" id="example-javascript-usage-11"><h2>Example JavaScript Usage</h2></a>
<pre><code class="language-js">import {
  take_boxed_number_slice_by_value,
  return_boxed_number_slice,
  take_option_boxed_number_slice,
  return_option_boxed_number_slice,
} from './guide_supported_types_examples';

take_boxed_number_slice_by_value(new Uint8Array(100));

let x = return_boxed_number_slice();
console.log(x instanceof Uint32Array); // true

take_option_boxed_number_slice(null);
take_option_boxed_number_slice(undefined);
take_option_boxed_number_slice(new Int16Array(256));

let y = return_option_boxed_number_slice();
if (y == null) {
  // ...
} else {
  console.log(x instanceof Int32Array); // true
}

</code></pre>
<a class="header" href="#resultt-jsvalue" id="resultt-jsvalue"><h1><code>Result&lt;T, JsValue&gt;</code></h1></a>
<table><thead><tr><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th><th align="center"> <code>Option&lt;T&gt;</code> parameter </th><th align="center"> <code>Option&lt;T&gt;</code> return value </th><th align="center"> JavaScript representation </th></tr></thead><tbody>
<tr><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Same as <code>T</code>, or an exception </td></tr>
</tbody></table>
<p>The <code>Result</code> type can be returned from functions exported to JS as well as
closures in Rust. Only <code>Result&lt;T, JsValue&gt;</code> is supported where <code>T</code> can be
converted to JS. Whenever <code>Ok(val)</code> is encountered it's converted to JS and
handed off, and whenever <code>Err(error)</code> is encountered an exception is thrown in
JS with <code>error</code>.</p>
<p>You can use <code>Result</code> to enable handling of JS exceptions with <code>?</code> in Rust,
naturally propagating it upwards to the wasm boundary. Furthermore you can also
return custom types in Rust so long as they're all convertible to <code>JsValue</code>.</p>
<p>Note that if you import a JS function with <code>Result</code> you need
<code>#[wasm_bindgen(catch)]</code> to be annotated on the import (unlike exported
functions, which require no extra annotation). This may not be necessary in the
future though and it may work &quot;as is&quot;!.</p>
<a class="header" href="#wasm_bindgen-attributes" id="wasm_bindgen-attributes"><h1><code>#[wasm_bindgen]</code> Attributes</h1></a>
<p>The <code>#[wasm_bindgen]</code> macro supports a good amount of configuration for
controlling precisely how exports are exported, how imports are imported, and
what the generated JavaScript glue ends up looking like. This section is an
exhaustive reference of the possibilities!</p>
<a class="header" href="#wasm_bindgen-on-javascript-imports" id="wasm_bindgen-on-javascript-imports"><h1><code>#[wasm_bindgen]</code> on JavaScript Imports</h1></a>
<p>This section enumerates the attributes available for customizing bindings for
JavaScript functions and classes imported into Rust within an <code>extern { ... }</code>
block.</p>
<a class="header" href="#catch" id="catch"><h1><code>catch</code></h1></a>
<p>The <code>catch</code> attribute allows catching a JavaScript exception. This can be
attached to any imported function or method, and the function must return a
<code>Result</code> where the <code>Err</code> payload is a <code>JsValue</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    // `catch` on a standalone function.
    #[wasm_bindgen(catch)]
    fn foo() -&gt; Result&lt;(), JsValue&gt;;

    // `catch` on a method.
    type Zoidberg;
    #[wasm_bindgen(catch, method)]
    fn woop_woop_woop(this: &amp;Zoidberg) -&gt; Result&lt;u32, JsValue&gt;;
}
#}</code></pre></pre>
<p>If calling the imported function throws an exception, then <code>Err</code> will be
returned with the exception that was raised. Otherwise, <code>Ok</code> is returned with
the result of the function.</p>
<blockquote>
<p>By default <code>wasm-bindgen</code> will take no action when wasm calls a JS function
which ends up throwing an exception. The wasm spec right now doesn't support
stack unwinding and as a result Rust code <strong>will not execute destructors</strong>.
This can unfortunately cause memory leaks in Rust right now, but as soon as
wasm implements catching exceptions we'll be sure to add support as well!</p>
</blockquote>
<a class="header" href="#constructor" id="constructor"><h1><code>constructor</code></h1></a>
<p>The <code>constructor</code> attribute is used to indicate that the function being bound
should actually translate to calling the <code>new</code> operator in JavaScript. The final
argument must be a type that's imported from JavaScript, and it's what will get
used in the generated glue:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Shoes;

    #[wasm_bindgen(constructor)]
    fn new() -&gt; Shoes;
}
#}</code></pre></pre>
<p>This will attach a <code>new</code> static method to the <code>Shoes</code> type, and in JavaScript
when this method is called, it will be equivalent to <code>new Shoes()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Become a cobbler; construct `new Shoes()`
let shoes = Shoes::new();
#}</code></pre></pre>
<a class="header" href="#extends--class" id="extends--class"><h1><code>extends = Class</code></h1></a>
<p>The <code>extends</code> attribute can be used to say that an imported type extends (in the
JS class hierarchy sense) another type. This will generate <code>AsRef</code>, <code>AsMut</code>, and
<code>From</code> impls for converting a type into another given that we statically know
the inheritance hierarchy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;

    #[wasm_bindgen(extends = Foo)]
    type Bar;
}

let x: &amp;Bar = ...;
let y: &amp;Foo = x.as_ref(); // zero cost cast
#}</code></pre></pre>
<p>The trait implementations generated for the above block are:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl From&lt;Bar&gt; for Foo { ... }
impl AsRef&lt;Foo&gt; for Bar { ... }
impl AsMut&lt;Foo&gt; for Bar { ... }
#}</code></pre></pre>
<p>The <code>extends = ...</code> attribute can be specified multiple times for longer
inheritance chains, and <code>AsRef</code> and such impls will be generated for each of
the types.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;

    #[wasm_bindgen(extends = Foo)]
    type Bar;

    #[wasm_bindgen(extends = Foo, extends = Bar)]
    type Baz;
}

let x: &amp;Baz = ...;
let y1: &amp;Bar = x.as_ref();
let y2: &amp;Foo = x.as_ref();
#}</code></pre></pre>
<a class="header" href="#getter-and-setter" id="getter-and-setter"><h1><code>getter</code> and <code>setter</code></h1></a>
<p>These two attributes can be combined with <code>method</code> to indicate that this is a
getter or setter method. A <code>getter</code>-tagged function by default accesses the
JavaScript property with the same name as the getter function. A <code>setter</code>'s
function name is currently required to start with <code>set_</code> and the property it
accesses is the suffix after <code>set\_</code>.</p>
<p>Consider the following JavaScript class that has a getter and setter for the
<code>white_russians</code> property:</p>
<pre><code class="language-js">class TheDude {
  get white_russians() {
    ...
  }
  set white_russians(val) {
    ...
  }
}
</code></pre>
<p>We would import this with the following <code>#[wasm_bindgen]</code> attributes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type TheDude;

    #[wasm_bindgen(method, getter)]
    fn white_russians(this: &amp;TheDude) -&gt; u32;

    #[wasm_bindgen(method, setter)]
    fn set_white_russians(this: &amp;TheDude, val: u32);
}
#}</code></pre></pre>
<p>Here we're importing the <code>TheDude</code> type and defining the ability to access each
object's <code>white_russians</code> property. The first function here is a getter and will
be available in Rust as <code>the_dude.white_russians()</code>, and the latter is the
setter which is accessible as <code>the_dude.set_white_russians(2)</code>. Note that both
functions have a <code>this</code> argument as they're tagged with <code>method</code>.</p>
<p>Finally, you can also pass an argument to the <code>getter</code> and <code>setter</code>
properties to configure what property is accessed. When the property is
explicitly specified then there is no restriction on the method name. For
example the below is equivalent to the above:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type TheDude;

    #[wasm_bindgen(method, getter = white_russians)]
    fn my_custom_getter_name(this: &amp;TheDude) -&gt; u32;

    #[wasm_bindgen(method, setter = white_russians)]
    fn my_custom_setter_name(this: &amp;TheDude, val: u32);
}
#}</code></pre></pre>
<p>Heads up! <code>getter</code> and <code>setter</code> functions are found on the constructor's
prototype chain once at load time, cached, and then the cached accessor is
invoked on each access. If you need to dynamically walk the prototype chain on
every access, add the <code>structural</code> attribute!</p>
<pre><code class="language-js">// This is the default function Rust will invoke on `the_dude.white_russians()`:
const white_russians = Object.getOwnPropertyDescriptor(
  TheDude.prototype,
  &quot;white_russians&quot;
).get;

// This is what you get by adding `structural`:
const white_russians = function(the_dude) {
  return the_dude.white_russians;
};
</code></pre>
<a class="header" href="#indexing_getter-indexing_setter-and-indexing_deleter" id="indexing_getter-indexing_setter-and-indexing_deleter"><h1><code>indexing_getter</code>, <code>indexing_setter</code>, and <code>indexing_deleter</code></h1></a>
<p>These three attributes indicate that a method is an dynamically intercepted
getter, setter, or deleter on the receiver object itself, rather than a direct
access of the receiver's properties. It is equivalent calling the Proxy handler
for the <code>obj[prop]</code> operation with some dynamic <code>prop</code> variable in JavaScript,
rather than a normal static property access like <code>obj.prop</code> on a normal
JavaScript <code>Object</code>.</p>
<p>This is useful for binding to <code>Proxy</code>s and some builtin DOM types that
dynamically intercept property accesses.</p>
<ul>
<li>
<p><code>indexing_getter</code> corresponds to <code>obj[prop]</code> operation in JavaScript. The
function annotated must have a <code>this</code> receiver parameter, a single parameter
that is used for indexing into the receiver (<code>prop</code>), and a return type.</p>
</li>
<li>
<p><code>indexing_setter</code> corresponds to the <code>obj[prop] = val</code> operation in
JavaScript. The function annotated must have a <code>this</code> receiver parameter, a
parameter for indexing into the receiver (<code>prop</code>), and a value parameter
(<code>val</code>).</p>
</li>
<li>
<p><code>indexing_deleter</code> corresponds to <code>delete obj[prop]</code> operation in
JavaScript. The function annotated must have a <code>this</code> receiver and a single
parameter for indexing into the receiver (<code>prop</code>).</p>
</li>
</ul>
<p>These must always be used in conjunction with the <code>structural</code> and <code>method</code>
flags.</p>
<p>For example, consider this JavaScript snippet that uses <code>Proxy</code>:</p>
<pre><code class="language-js">const foo = new Proxy({}, {
    get(obj, prop) {
        return prop in obj ? obj[prop] : prop.length;
    },
    set(obj, prop, value) {
        obj[prop] = value;
    },
    deleteProperty(obj, prop) {
        delete obj[prop];
    },
});

foo.ten;
// 3

foo.ten = 10;
foo.ten;
// 10

delete foo.ten;
foo.ten;
// 3
</code></pre>
<p>To bind that in <code>wasm-bindgen</code> in Rust, we would use the <code>indexing_*</code> attributes
on methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    static foo: Foo;

    #[wasm_bindgen(method, structural, indexing_getter)]
    fn get(this: &amp;Foo, prop: &amp;str) -&gt; u32;

    #[wasm_bindgen(method, structural, indexing_setter)]
    fn set(this: &amp;Foo, prop: &amp;str, val: u32);

    #[wasm_bindgen(method, structural, indexing_deleter)]
    fn delete(this: &amp;Foo, prop: &amp;str);
}

assert_eq!(foo.get(&quot;ten&quot;), 3);

foo.set(&quot;ten&quot;, 10);
assert_eq!(foo.get(&quot;ten&quot;), 10);

foo.delete(&quot;ten&quot;);
assert_eq!(foo.get(&quot;ten&quot;), 3);
#}</code></pre></pre>
<a class="header" href="#js_class--blah" id="js_class--blah"><h1><code>js_class = &quot;Blah&quot;</code></h1></a>
<p>The <code>js_class</code> attribute can be used in conjunction with the <code>method</code> attribute
to bind methods of imported JavaScript classes that have been renamed on the
Rust side.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    // We don't want to import JS strings as `String`, since Rust already has a
    // `String` type in its prelude, so rename it as `JsString`.
    #[wasm_bindgen(js_name = String)]
    type JsString;

    // This is a method on the JavaScript &quot;String&quot; class, so specify that with
    // the `js_class` attribute.
    #[wasm_bindgen(method, js_class = &quot;String&quot;, js_name = charAt)]
    fn char_at(this: &amp;JsString, index: u32) -&gt; JsString;
}
#}</code></pre></pre>
<a class="header" href="#js_name--blah" id="js_name--blah"><h1><code>js_name = blah</code></h1></a>
<p>The <code>js_name</code> attribute can be used to bind to a different function in
JavaScript than the identifier that's defined in Rust.</p>
<p>Most often, this is used to convert a camel-cased JavaScript identifier into a
snake-cased Rust identifier:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_name = jsOftenUsesCamelCase)]
    fn js_often_uses_camel_case() -&gt; u32;
}
#}</code></pre></pre>
<p>Sometimes, it is used to bind to JavaScript identifiers that are not valid Rust
identifiers, in which case <code>js_name = &quot;some string&quot;</code> is used instead of <code>js_name = ident</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_name = &quot;$$$&quot;)]
    fn cash_money() -&gt; u32;
}
#}</code></pre></pre>
<p>However, you can also use <code>js_name</code> to define multiple signatures for
polymorphic JavaScript functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn console_log_str(s: &amp;str);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn console_log_u32(n: u32);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn console_log_many(a: u32, b: &amp;JsValue);
}
#}</code></pre></pre>
<p>All of these functions will call <code>console.log</code> in JavaScript, but each
identifier will have only one signature in Rust.</p>
<a class="header" href="#js_namespace--blah" id="js_namespace--blah"><h1><code>js_namespace = blah</code></h1></a>
<p>This attribute indicates that the JavaScript type is accessed through the given
namespace. For example, the <code>WebAssembly.Module</code> APIs are all accessed through
the <code>WebAssembly</code> namespace. <code>js_namespace</code> can be applied to any import
(function or type) and whenever the generated JavaScript attempts to reference a
name (like a class or function name) it'll be accessed through this namespace.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

log(&quot;hello, console!&quot;);
#}</code></pre></pre>
<p>This is an example of how to bind <code>console.log</code> in Rust. The <code>log</code> function will
be available in the Rust module and will be invoked as <code>console.log</code> in
JavaScript.</p>
<a class="header" href="#method" id="method"><h1><code>method</code></h1></a>
<p>The <code>method</code> attribute allows you to describe methods of imported JavaScript
objects. It is applied on a function that has <code>this</code> as its first parameter,
which is a shared reference to an imported JavaScript type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Set;

    #[wasm_bindgen(method)]
    fn has(this: &amp;Set, element: &amp;JsValue) -&gt; bool;
}
#}</code></pre></pre>
<p>This generates a <code>has</code> method on <code>Set</code> in Rust, which invokes the
<code>Set.prototype.has</code> method in JavaScript.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let set: Set = ...;
let elem: JsValue = ...;
if set.has(&amp;elem) {
    ...
}
#}</code></pre></pre>
<a class="header" href="#module--blah" id="module--blah"><h1><code>module = &quot;blah&quot;</code></h1></a>
<p>The <code>module</code> attributes configures the module from which items are imported. For
example,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(module = &quot;wu/tang/clan&quot;)]
extern {
    type ThirtySixChambers;
}
#}</code></pre></pre>
<p>generates JavaScript import glue like:</p>
<pre><code class="language-js">import { ThirtySixChambers } from &quot;wu/tang/clan&quot;;
</code></pre>
<p>If a <code>module</code> attribute is not present, then the global scope is used
instead. For example,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn illmatic() -&gt; u32;
}
#}</code></pre></pre>
<p>generates JavaScript import glue like:</p>
<pre><code class="language-js">let illmatic = this.illmatic;
</code></pre>
<a class="header" href="#static_method_of--blah" id="static_method_of--blah"><h1><code>static_method_of = Blah</code></h1></a>
<p>The <code>static_method_of</code> attribute allows one to specify that an imported function
is a static method of the given imported JavaScript class. For example, to bind
to JavaScript's <code>Date.now()</code> static method, one would use this attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Date;

    #[wasm_bindgen(static_method_of = Date)]
    pub fn now() -&gt; f64;
}
#}</code></pre></pre>
<p>The <code>now</code> function becomes a static method of the imported type in the Rust
bindings as well:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let instant = Date::now();
#}</code></pre></pre>
<p>This is similar to the <code>js_namespace</code> attribute, but the usage from within Rust
is different since the method also becomes a static method of the imported type.</p>
<a class="header" href="#structural" id="structural"><h1><code>structural</code></h1></a>
<p>The <code>structural</code> flag can be added to <code>method</code> annotations, indicating that the
method being accessed (or property with getters/setters) should be accessed in a
structural, duck-type-y fashion. Rather than walking the constructor's prototype
chain once at load time and caching the property result, the prototype chain is
dynamically walked on every access.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Duck;

    #[wasm_bindgen(method, structural)]
    fn quack(this: &amp;Duck);

    #[wasm_bindgen(method, getter, structural)]
    fn is_swimming(this: &amp;Duck) -&gt; bool;
}
#}</code></pre></pre>
<p>The constructor for the type here, <code>Duck</code>, is not required to exist in
JavaScript (it's not referenced).  Instead <code>wasm-bindgen</code> will generate shims
that will access the passed in JavaScript value's <code>quack</code> method or its
<code>is_swimming</code> property.</p>
<pre><code class="language-js">// Without `structural`, get the method directly off the prototype at load time:
const Duck_prototype_quack = Duck.prototype.quack;
function quack(duck) {
  Duck_prototype_quack.call(duck);
}

// With `structural`, walk the prototype chain on every access:
function quack(duck) {
  duck.quack();
}
</code></pre>
<a class="header" href="#why-dont-we-always-use-the-structural-behavior" id="why-dont-we-always-use-the-structural-behavior"><h2>Why don't we always use the <code>structural</code> behavior?</h2></a>
<p>In theory, it is faster since the prototype chain doesn't need to be traversed
every time the method or property is accessed, but today's optimizing JIT
compilers are really good about eliminating that cost. The real reason is to be
future compatible with the <a href="https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md">&quot;host bindings&quot; proposal</a>, which
requires that there be no JavaScript shim between the caller and the native host
function. In this scenario, the properties and methods <em>must</em> be resolved before
the wasm is instantiated.</p>
<a class="header" href="#variadic-parameters" id="variadic-parameters"><h1>Variadic Parameters</h1></a>
<p>In javascript, both the types of function arguments, and the number of function arguments are
dynamic. For example</p>
<pre><code class="language-js">function sum(...rest) {
    let i;
    // the old way
    let old_way = 0;
    for (i=0; i&lt;arguments.length; i++) {
        old_way += arguments[i];
    }
    // the new way
    let new_way = 0;
    for (i=0; i&lt;rest.length; i++) {
        new_way += rest[i];
    }
    // both give the same answer
    assert(old_way === new_way);
    return new_way;
}
</code></pre>
<p>This function doesn't translate directly into rust, since we don't currently support variadic
arguments on the wasm target. To bind to it, we use a slice as the last argument, and annotate the
function as variadic:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(variadic)]
    fn sum(args: &amp;[i32]) -&gt; i32;
}
#}</code></pre></pre>
<p>when we call this function, the last argument will be expanded as the javascript expects.</p>
<a class="header" href="#wasm_bindgen-on-rust-exports" id="wasm_bindgen-on-rust-exports"><h1><code>#[wasm_bindgen]</code> on Rust Exports</h1></a>
<p>This section enumerates the attributes available for customizing bindings for
Rust functions and <code>struct</code>s exported to JavaScript.</p>
<a class="header" href="#constructor-1" id="constructor-1"><h1><code>constructor</code></h1></a>
<p>When attached to a Rust &quot;constructor&quot; it will make the generated JavaScript
bindings callable as <code>new Foo()</code>.</p>
<p>For example, consider this exported Rust type and <code>constructor</code> annotation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Foo {
    contents: u32,
}

#[wasm_bindgen]
impl Foo {
    #[wasm_bindgen(constructor)]
    pub fn new() -&gt; Foo {
        Foo { contents: 0 }
    }

    pub fn get_contents(&amp;self) -&gt; u32 {
        self.contents
    }
}
#}</code></pre></pre>
<p>This can be used in JavaScript as:</p>
<pre><code class="language-js">import { Foo } from './my_module';

const f = new Foo();
console.log(f.get_contents());
</code></pre>
<a class="header" href="#js_name--blah-1" id="js_name--blah-1"><h1><code>js_name = Blah</code></h1></a>
<p>The <code>js_name</code> attribute can be used to export a different name in JS than what
something is named in Rust. It can be applied to both exported Rust functions
and types.</p>
<p>For example, this is often used to convert between Rust's snake-cased
identifiers into JavaScript's camel-cased identifiers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(js_name = doTheThing)]
pub fn do_the_thing() -&gt; u32 {
    42
}
#}</code></pre></pre>
<p>This can be used in JavaScript as:</p>
<pre><code class="language-js">import { doTheThing } from './my_module';

const x = doTheThing();
console.log(x);
</code></pre>
<a class="header" href="#readonly" id="readonly"><h1><code>readonly</code></h1></a>
<p>When attached to a <code>pub</code> struct field this indicates that it's read-only from
JavaScript, and a setter will not be generated and exported to JavaScript.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn make_foo() -&gt; Foo {
    Foo {
        first: 10,
        second: 20,
    }
}

#[wasm_bindgen]
pub struct Foo {
    pub first: u32,

    #[wasm_bindgen(readonly)]
    pub second: u32,
}
#}</code></pre></pre>
<p>Here the <code>first</code> field will be both readable and writable from JS, but the
<code>second</code> field will be a <code>readonly</code> field in JS where the setter isn't
implemented and attempting to set it will throw an exception.</p>
<pre><code class="language-js">import { make_foo } from &quot;./my_module&quot;;

const foo = make_foo();

// Can both get and set `first`.
foo.first = 99;
console.log(foo.first);

// Can only get `second`.
console.log(foo.second);
</code></pre>
<a class="header" href="#the-web-sys-crate" id="the-web-sys-crate"><h1>The <code>web-sys</code> Crate</h1></a>
<p>The <code>web-sys</code> crate provides raw <code>wasm-bindgen</code> imports for all of the Web's
APIs. This includes:</p>
<ul>
<li><code>window.fetch</code></li>
<li><code>Node.prototype.appendChild</code></li>
<li>WebGL</li>
<li>WebAudio</li>
<li>and many more!</li>
</ul>
<p>It's sort of like the <code>libc</code> crate, but for the Web.</p>
<p>It does <em>not</em> include the JavaScript APIs that are guaranteed to exist in all
standards-compliant ECMAScript environments, such as <code>Array</code>, <code>Date</code>, and
<code>eval</code>. Bindings for these APIs can be found in <a href="https://crates.io/crates/js-sys">the <code>js-sys</code> crate</a>.</p>
<a class="header" href="#api-documentation" id="api-documentation"><h2>API Documentation</h2></a>
<p><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/"><strong>Read the <code>web-sys</code> API documentation here!</strong></a></p>
<a class="header" href="#using-web-sys" id="using-web-sys"><h1>Using <code>web-sys</code></h1></a>
<a class="header" href="#add-web-sys-as-a-dependency-to-your-cargotoml" id="add-web-sys-as-a-dependency-to-your-cargotoml"><h2>Add <code>web-sys</code> as a dependency to your <code>Cargo.toml</code></h2></a>
<p><em><strong>Note:</strong> <code>web-sys</code> is not available on crates.io yet, so you'll need to depend
on the git version of it, and of <code>wasm-bindgen</code>:</em></p>
<pre><code class="language-toml">[dependencies]
wasm-bindgen = { git = &quot;https://github.com/rustwasm/wasm-bindgen&quot; }

[dependencies.web-sys]
git = &quot;https://github.com/rustwasm/wasm-bindgen&quot;
features = [
]
</code></pre>
<a class="header" href="#enable-the-cargo-features-for-the-apis-youre-using" id="enable-the-cargo-features-for-the-apis-youre-using"><h2>Enable the cargo features for the APIs you're using</h2></a>
<p>To keep build times super speedy, <a href="./cargo-features.html"><code>web-sys</code> gates each Web interface behind a
cargo feature</a>. Find the type or method you want to use
in the <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/">API documentation</a>; it will list the features that must be enabled
to access that API.</p>
<p>For example, if we're looking for <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/resizeTo">the <code>window.resizeTo</code>
function</a>, we would <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/?search=resizeTo">search for <code>resizeTo</code> in the API
documentation</a>. We would find <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.resize_to">the
<code>web_sys::Window::resize_to</code> function</a>, which requires the
<code>Window</code> feature. To get access to that function, we enable the <code>Window</code> feature
in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies.web-sys]
git = &quot;https://github.com/rustwasm/wasm-bindgen&quot;
features = [
  &quot;Window&quot;
]
</code></pre>
<a class="header" href="#call-the-method" id="call-the-method"><h2>Call the method!</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate web_sys;
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;
use web_sys::Window;

#[wasm_bindgen]
pub fn make_the_window_small() {
    // Resize the window to 500px by 500px.
    Window::resize_to(500, 500)
        .expect(&quot;could not resize the window&quot;);
}
#}</code></pre></pre>
<a class="header" href="#cargo-features-in-web-sys" id="cargo-features-in-web-sys"><h1>Cargo Features in <code>web-sys</code></h1></a>
<p>To keep <code>web-sys</code> building as fast as possible, there is a cargo feature for
every type defined in <code>web-sys</code>. To access that type, you must enable its
feature. To access a method, you must enable the feature for its <code>self</code> type and
the features for each of its argument types. In the <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys">API documentation</a>, every
method lists the features that are required to enable it.</p>
<p>For example, <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.WebGlRenderingContext.html#method.compile_shader">the <code>WebGlRenderingContext::compile_shader</code> function</a> requires these features:</p>
<ul>
<li><code>WebGlRenderingContext</code>, because that is the method's <code>self</code> type</li>
<li><code>WebGlShader</code>, because it takes an argument of that type</li>
</ul>
<a class="header" href="#function-overloads" id="function-overloads"><h1>Function Overloads</h1></a>
<p>Many Web APIs are overloaded to take different types of arguments or to skip
arguments completely. <code>web-sys</code> contains multiple bindings for these functions
that each specialize to a particular overload and set of argument types.</p>
<p>For example, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">the <code>fetch</code> API</a> can be given a URL string, or a
<code>Request</code> object, and it might also optionally be given a <code>RequestInit</code> options
object. Therefore, we end up with these <code>web-sys</code> functions that all bind to the
<code>window.fetch</code> function:</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.fetch_with_str"><code>Window::fetch_with_str</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.fetch_with_request"><code>Window::fetch_with_request</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/str_and_inituct.Window.html#method.fetch_with_str_and_init"><code>Window::fetch_with_str_and_init</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.fetch_with_request_and_init"><code>Window::fetch_with_request_and_init</code></a></li>
</ul>
<p>Note that different overloads can use different interfaces, and therefore can
require different sets of cargo features to be enabled.</p>
<a class="header" href="#type-translations-in-web-sys" id="type-translations-in-web-sys"><h1>Type Translations in <code>web-sys</code></h1></a>
<p>Most of the types specified in <a href="https://heycam.github.io/webidl/">WebIDL (the interface definition language for
all Web APIs)</a> have relatively straightforward translations into
<code>web-sys</code>, but it's worth calling out a few in particular:</p>
<ul>
<li>
<p><code>BufferSource</code> and <code>ArrayBufferView</code> - these two types show up in a number of
APIs that generally deal with a buffer of bytes. We bind them in <code>web-sys</code>
with two different types, <code>js_sys::Object</code> and <code>&amp;mut [u8]</code>. Using
<code>js_sys::Object</code> allows passing in arbitrary JS values which represent a view
of bytes (like any typed array object), and <code>&amp;mut [u8]</code> allows using a raw
slice in Rust. Unfortunately we must pessimistically assume that JS will
modify all slices as we don't currently have information of whether they're
modified or not.</p>
</li>
<li>
<p>Callbacks are all represented as <code>js_sys::Function</code>. This means that all
callbacks going through <code>web-sys</code> are a raw JS value. You can work with this
by either juggling actual <code>js_sys::Function</code> instances or you can create a
<code>Closure&lt;FnMut(...)&gt;</code>, extract the underlying <code>JsValue</code> with <code>as_ref</code>, and
then use <code>JsCast::unchecked_ref</code> to convert it to a <code>js_sys::Function</code>.</p>
</li>
</ul>
<a class="header" href="#testing-on-wasm32-unknown-unknown-with-wasm-bindgen-test" id="testing-on-wasm32-unknown-unknown-with-wasm-bindgen-test"><h1>Testing on <code>wasm32-unknown-unknown</code> with <code>wasm-bindgen-test</code></h1></a>
<p>The <code>wasm-bindgen-test</code> crate is an experimental test harness for Rust programs
compiled to wasm using <code>wasm-bindgen</code> and the <code>wasm32-unknown-unknown</code>
target.</p>
<a class="header" href="#goals" id="goals"><h2>Goals</h2></a>
<ul>
<li>
<p>Write tests for wasm as similar as possible to how you normally would write
<code>#[test]</code>-style unit tests for native targets.</p>
</li>
<li>
<p>Run the tests with the usual <code>cargo test</code> command but with an explicit wasm
target:</p>
<pre><code>cargo test --target wasm32-unknown-unknown
</code></pre>
</li>
</ul>
<a class="header" href="#using-wasm-bindgen-test" id="using-wasm-bindgen-test"><h1>Using <code>wasm-bindgen-test</code></h1></a>
<a class="header" href="#install-the-test-runner" id="install-the-test-runner"><h2>Install the Test Runner</h2></a>
<blockquote>
<p>⚡ If you are using <code>wasm-pack</code>, skip this step! <code>wasm-pack test</code> will
automatically ensure that the right version of the test runner is installed.</p>
</blockquote>
<p>The test runner comes along with the main <code>wasm-bindgen</code> CLI tool. Make sure to
replace &quot;X.Y.Z&quot; with the same version of <code>wasm-bindgen</code> that you already have in
<code>Cargo.toml</code>!</p>
<pre><code class="language-shell">cargo install wasm-bindgen-cli --vers &quot;X.Y.Z&quot;
</code></pre>
<a class="header" href="#configure-cargoconfig-to-use-the-test-runner" id="configure-cargoconfig-to-use-the-test-runner"><h2>Configure <code>.cargo/config</code> to use the Test Runner</h2></a>
<blockquote>
<p>⚡ If you are using <code>wasm-pack</code>, skip this step! <code>wasm-pack test</code> will
automatically configure <code>cargo test</code> to use the <code>wasm-bindgen</code> test runner.</p>
</blockquote>
<p>Add this to <code>$MY_CRATE/.cargo/config</code>:</p>
<pre><code class="language-toml">[target.wasm32-unknown-unknown]
runner = 'wasm-bindgen-test-runner'
</code></pre>
<a class="header" href="#add-wasm-bindgen-test-to-your-cargotomls-dev-dependencies" id="add-wasm-bindgen-test-to-your-cargotomls-dev-dependencies"><h2>Add <code>wasm-bindgen-test</code> to Your <code>Cargo.toml</code>'s <code>[dev-dependencies]</code></h2></a>
<p>Make sure to replace &quot;X.Y.Z&quot; with the same version of <code>wasm-bindgen</code> that you
have in the <code>[dependencies]</code> section!</p>
<pre><code class="language-toml">[dev-dependencies]
wasm-bindgen-test = &quot;X.Y.Z&quot;
</code></pre>
<a class="header" href="#write-some-tests" id="write-some-tests"><h2>Write Some Tests</h2></a>
<p>Create a <code>$MY_CRATE/tests/wasm.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate wasm_bindgen_test;
use wasm_bindgen_test::*;

#[wasm_bindgen_test]
fn pass() {
    assert_eq!(1, 1);
}

#[wasm_bindgen_test]
fn fail() {
    assert_eq!(1, 2);
}
#}</code></pre></pre>
<p>Writing tests is the same as normal Rust <code>#[test]</code>s, except we are using the
<code>#[wasm_bindgen_test]</code> attribute.</p>
<p>One other difference is that the tests <strong>must</strong> be in the root of the crate, or
within a <code>pub mod</code>. Putting them inside a private module will not work.</p>
<a class="header" href="#execute-your-tests" id="execute-your-tests"><h2>Execute Your Tests</h2></a>
<blockquote>
<p>⚡ If you are using <code>wasm-pack</code>, run <code>wasm-pack test</code> instead! For more
details, run <code>wasm-pack test --help</code>.</p>
</blockquote>
<p>Run the tests by specifying the <code>wasm32-unknown-unknown</code> target when running
<code>cargo test</code>. By default, the tests are run in Node.js, but you can <a href="./browsers.html">configure
tests to run inside headless browsers</a> as well.</p>
<pre><code class="language-shell">$ cargo test --target wasm32-unknown-unknown
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running /home/.../target/wasm32-unknown-unknown/debug/deps/wasm-4a309ffe6ad80503.wasm
running 2 tests

test wasm::pass ... ok
test wasm::fail ... FAILED

failures:

---- wasm::fail output ----
    error output:
        panicked at 'assertion failed: `(left == right)`
          left: `1`,
         right: `2`', crates/test/tests/wasm.rs:14:5

    JS exception that was thrown:
        RuntimeError: unreachable
            at __rust_start_panic (wasm-function[1362]:33)
            at rust_panic (wasm-function[1357]:30)
            at std::panicking::rust_panic_with_hook::h56e5e464b0e7fc22 (wasm-function[1352]:444)
            at std::panicking::continue_panic_fmt::had70ba48785b9a8f (wasm-function[1350]:122)
            at std::panicking::begin_panic_fmt::h991e7d1ca9bf9c0c (wasm-function[1351]:95)
            at wasm::fail::ha4c23c69dfa0eea9 (wasm-function[88]:477)
            at core::ops::function::FnOnce::call_once::h633718dad359559a (wasm-function[21]:22)
            at wasm_bindgen_test::__rt::Context::execute::h2f669104986475eb (wasm-function[13]:291)
            at __wbg_test_fail_1 (wasm-function[87]:57)
            at module.exports.__wbg_apply_2ba774592c5223a7 (/home/alex/code/wasm-bindgen/target/wasm32-unknown-unknown/wbg-tmp/wasm-4a309ffe6ad80503.js:61:66)


failures:

    wasm::fail

test result: FAILED. 1 passed; 1 failed; 0 ignored

error: test failed, to rerun pass '--test wasm'
</code></pre>
<a class="header" href="#writing-asynchronous-tests" id="writing-asynchronous-tests"><h1>Writing Asynchronous Tests</h1></a>
<p>Not all tests can execute immediately and some may need to do &quot;blocking&quot; work
like fetching resources and/or other bits and pieces. To accommodate this
asynchronous tests are also supported through the <code>futures</code> and
<code>wasm-bindgen-futures</code> crates.</p>
<p>To write an asynchronous test:</p>
<ol>
<li>
<p>Change <code>#[wasm_bindgen_test]</code> into <code>#[wasm_bindgen_test(async)]</code></p>
</li>
<li>
<p>Change the return type of the test function to <code>impl Future&lt;Item = (), Error = JsValue&gt;</code></p>
</li>
</ol>
<p>The test will pass if the future resolves without panicking or returning an
error, and otherwise the test will fail.</p>
<a class="header" href="#example-1" id="example-1"><h2>Example</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate futures;
extern crate js_sys;
extern crate wasm_bindgen_futures;

use futures::Future;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;

#[wasm_bindgen_test(async)]
fn my_async_test() -&gt; impl Future&lt;Item = (), Error = JsValue&gt; {
    // Create a promise that is ready on the next tick of the micro task queue.
    let promise = js_sys::Promise::resolve(&amp;JsValue::from(42));

    // Convert that promise into a future and make the test wait on it.
    JsFuture::from(promise)
        .map(|x| {
            assert_eq!(x, 42);
        })
        .map_err(|_| unreachable!())
}
#}</code></pre></pre>
<a class="header" href="#testing-in-headless-browsers" id="testing-in-headless-browsers"><h1>Testing in Headless Browsers</h1></a>
<a class="header" href="#configure-your-test-crate" id="configure-your-test-crate"><h2>Configure Your Test Crate</h2></a>
<p>Add this to the root of your test crate, e.g. <code>$MY_CRATE/tests/wasm.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen_test::wasm_bindgen_test_configure;

wasm_bindgen_test_configure!(run_in_browser);
#}</code></pre></pre>
<a class="header" href="#configuring-which-browser-is-used" id="configuring-which-browser-is-used"><h2>Configuring Which Browser is Used</h2></a>
<blockquote>
<p>⚡ If you are using <code>wasm-pack</code>, skip this step! Instead, use <code>wasm-pack test --chrome</code>, <code>wasm-pack test --firefox</code>, or <code>wasm-pack test --safari</code>.
<code>wasm-pack</code> will automatically download and configure the appropriate
WebDriver client for you.</p>
</blockquote>
<p>If one of the following environment variables is set, then the corresponding
WebDriver and browser will be used. If none of these environment variables are
set, then the <code>$PATH</code> is searched for a suitable WebDriver implementation.</p>
<a class="header" href="#geckodriverpathtogeckodriver" id="geckodriverpathtogeckodriver"><h4><code>GECKODRIVER=path/to/geckodriver</code></h4></a>
<p>Use Firefox for headless browser testing, and <code>geckodriver</code> as its
WebDriver.</p>
<p>The <code>firefox</code> binary must be on your <code>$PATH</code>.</p>
<p><a href="https://github.com/mozilla/geckodriver/releases">Get <code>geckodriver</code> here</a></p>
<a class="header" href="#chromedriverpathtochromedriver" id="chromedriverpathtochromedriver"><h4><code>CHROMEDRIVER=path/to/chromedriver</code></h4></a>
<p>Use Chrome for headless browser testing, and <code>chromedriver</code> as its
WebDriver.</p>
<p>The <code>chrome</code> binary must be on your <code>$PATH</code>.</p>
<p><a href="http://chromedriver.chromium.org/downloads">Get <code>chromedriver</code> here</a></p>
<a class="header" href="#safaridriverpathtosafaridriver" id="safaridriverpathtosafaridriver"><h4><code>SAFARIDRIVER=path/to/safaridriver</code></h4></a>
<p>Use Safari for headless browser testing, and <code>safaridriver</code> as its
WebDriver.</p>
<p>This is installed by default on Mac OS. It should be able to find your Safari
installation by default.</p>
<a class="header" href="#running-the-tests-in-the-headless-browser" id="running-the-tests-in-the-headless-browser"><h2>Running the Tests in the Headless Browser</h2></a>
<p>Once the tests are configured to run in a headless browser, executing the tests
is the same:</p>
<pre><code class="language-bash">cargo test --target wasm32-unknown-unknown

# or, if you're using wasm-pack
wasm-pack test --headless --chrome --firefox --safari
</code></pre>
<a class="header" href="#debugging-headless-browser-tests" id="debugging-headless-browser-tests"><h3>Debugging Headless Browser Tests</h3></a>
<blockquote>
<p>If you're using <code>wasm-pack</code>, omitting the <code>--headless</code> flag will disable
headless mode, and allow you to debug failing tests in your browser's
devtools.</p>
</blockquote>
<p>Set the <code>NO_HEADLESS=1</code> environment variable and the browser tests will not run
headless. Instead, the tests will start a local server that you can visit in
your Web browser of choices, and headless testing should not be used. You can
then use your browser's devtools to debug.</p>
<a class="header" href="#setting-up-continuous-integration-with-wasm-bindgen-test" id="setting-up-continuous-integration-with-wasm-bindgen-test"><h1>Setting Up Continuous Integration with <code>wasm-bindgen-test</code></h1></a>
<p>This page contains example configurations for running <code>wasm-bindgen-test</code>-based
tests in various CI services.</p>
<p>Is your favorite CI service missing? <a href="https://github.com/rustwasm/wasm-bindgen">Send us a pull
request!</a></p>
<a class="header" href="#travis-ci" id="travis-ci"><h2>Travis CI</h2></a>
<pre><code class="language-yaml">language: rust
rust: nightly

addons:
  firefox: latest
  chrome: stable

install:
  - rustup target add wasm32-unknown-unknown
  # Downloads a `wasm-bindgen` release binary from https://github.com/rustwasm/wasm-bindgen/releases.
  # Alternatively, use `wasm-pack` to manage `wasm-bindgen` binaries for you
  - curl -OL https://github.com/rustwasm/wasm-bindgen/releases/download/0.2.21/wasm-bindgen-0.2.21-x86_64-unknown-linux-musl.tar.gz
  - tar xf wasm-bindgen-0.2.21-x86_64-unknown-linux-musl.tar.gz
  - chmod +x wasm-bindgen-0.2.21-x86_64-unknown-linux-musl/wasm-bindgen
  # Moves the binaries to a directory that is in your PATH
  - mv wasm-bindgen-0.2.19-x86_64-unknown-linux-musl/wasm-bindgen* ~/.cargo/bin 
  # Install node.js with nvm.
  - curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
  - source ~/.nvm/nvm.sh
  - nvm install v10.5
  # Install chromedriver.
  - curl --retry 5 -LO https://chromedriver.storage.googleapis.com/2.41/chromedriver_linux64.zip
  - unzip chromedriver_linux64.zip
  # Install geckodriver.
  - curl --retry 5 -LO https://github.com/mozilla/geckodriver/releases/download/v0.21.0/geckodriver-v0.21.0-linux64.tar.gz
  - tar xf geckodriver-v0.21.0-linux64.tar.gz

script:
  # Test in Chrome.
  - CHROMEDRIVER=$(pwd)/chromedriver cargo test --target wasm32-unknown-unknown
  # Test in Firefox.
  - GECKODRIVER=$(pwd)/geckodriver cargo test --target wasm32-unknown-unknown
</code></pre>
<a class="header" href="#appveyor" id="appveyor"><h2>AppVeyor</h2></a>
<pre><code class="language-yaml">install:
  - ps: Install-Product node 10
  - appveyor-retry appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe
  - rustup-init.exe -y --default-host x86_64-pc-windows-msvc --default-toolchain nightly
  - set PATH=%PATH%;C:\Users\appveyor\.cargo\bin
  - rustc -V
  - cargo -V
  - rustup target add wasm32-unknown-unknown
  - cargo install wasm-bindgen-cli

build: false

test_script:
  # Test in Chrome. chromedriver is installed by default in appveyor.
  - set CHROMEDRIVER=C:\Tools\WebDriver\chromedriver.exe
  - cargo test --target wasm32-unknown-unknown
  - set CHROMEDRIVER=
  # Test in Firefox. geckodriver is also installed by default.
  - set GECKODRIVER=C:\Tools\WebDriver\geckodriver.exe
  - cargo test --target wasm32-unknown-unknown
</code></pre>
<a class="header" href="#contributing-to-wasm-bindgen" id="contributing-to-wasm-bindgen"><h1>Contributing to <code>wasm-bindgen</code></h1></a>
<p>This section contains instructions on how to get this project up and running for
development.</p>
<a class="header" href="#prerequisites" id="prerequisites"><h2>Prerequisites</h2></a>
<ol>
<li>
<p>Rust Nightly. <a href="https://www.rust-lang.org/en-US/install.html">Install Rust</a>. Once Rust is installed, run</p>
<pre><code class="language-shell">rustup default nightly
rustup target add wasm32-unknown-unknown
</code></pre>
</li>
</ol>
<ol start="2">
<li>The tests for this project use Node. Make sure you have node &gt;= 10 installed,
as that is when WebAssembly support was introduced. <a href="https://nodejs.org/en/">Install Node</a>.</li>
</ol>
<a class="header" href="#running-wasm-bindgens-tests" id="running-wasm-bindgens-tests"><h1>Running <code>wasm-bindgen</code>'s Tests</h1></a>
<a class="header" href="#wasm-tests-on-node-and-headless-browsers" id="wasm-tests-on-node-and-headless-browsers"><h2>Wasm Tests on Node and Headless Browsers</h2></a>
<p>These are the largest test suites, and most common to run in day to day
<code>wasm-bindgen</code> development. These tests are compiled to Wasm and then run in
Node.js or a headless browser via the WebDriver protocol.</p>
<pre><code class="language-bash">cargo test --target wasm32-unknown-unknown
</code></pre>
<p>See <a href="https://github.com/rustwasm/wasm-bindgen/blob/master/crates/test/README.md">the <code>wasm-bindgen-test</code> crate's
<code>README.md</code></a>
for details and configuring which headless browser is used.</p>
<a class="header" href="#sanity-tests-for-wasm-bindgen-on-the-native-host-target" id="sanity-tests-for-wasm-bindgen-on-the-native-host-target"><h2>Sanity Tests for <code>wasm-bindgen</code> on the Native Host Target</h2></a>
<p>This small test suite just verifies that exported <code>wasm-bindgen</code> methods can
still be used on the native host's target.</p>
<pre><code>cargo test
</code></pre>
<a class="header" href="#the-web-idl-frontends-tests" id="the-web-idl-frontends-tests"><h2>The Web IDL Frontend's Tests</h2></a>
<pre><code>cargo test -p webidl-tests --target wasm32-unknown-unknown
</code></pre>
<a class="header" href="#the-macro-ui-tests" id="the-macro-ui-tests"><h2>The Macro UI Tests</h2></a>
<p>These tests assert that we have reasonable error messages that point to the
right source spans when the <code>#[wasm_bindgen]</code> proc-macro is misused.</p>
<pre><code>cargo test -p ui-tests
</code></pre>
<a class="header" href="#the-js-sys-tests" id="the-js-sys-tests"><h2>The <code>js-sys</code> Tests</h2></a>
<p>See <a href="js-sys/testing.html">the <code>js-sys</code> testing page</a>.</p>
<a class="header" href="#the-web-sys-tests" id="the-web-sys-tests"><h2>The <code>web-sys</code> Tests</h2></a>
<p>See <a href="web-sys/testing.html">the <code>web-sys</code> testing page</a>.</p>
<a class="header" href="#design-of-wasm-bindgen" id="design-of-wasm-bindgen"><h1>Design of <code>wasm-bindgen</code></h1></a>
<p>This section is intended to be a deep-dive into how <code>wasm-bindgen</code> internally
works today, specifically for Rust. If you're reading this far in the future it
may no longer be up to date, but feel free to open an issue and we can try to
answer questions and/or update this!</p>
<a class="header" href="#foundation-es-modules" id="foundation-es-modules"><h2>Foundation: ES Modules</h2></a>
<p>The first thing to know about <code>wasm-bindgen</code> is that it's fundamentally built on
the idea of ES Modules. In other words this tool takes an opinionated stance
that wasm files <em>should be viewed as ES modules</em>. This means that you can
<code>import</code> from a wasm file, use its <code>export</code>-ed functionality, etc, from normal
JS files.</p>
<p>Now unfortunately at the time of this writing the interface of wasm interop
isn't very rich. Wasm modules can only call functions or export functions that
deal exclusively with <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code>. Bummer!</p>
<p>That's where this project comes in. The goal of <code>wasm-bindgen</code> is to enhance the
&quot;ABI&quot; of wasm modules with richer types like classes, JS objects, Rust structs,
strings, etc. Keep in mind, though, that everything is based on ES Modules! This
means that the compiler is actually producing a &quot;broken&quot; wasm file of sorts. The
wasm file emitted by rustc, for example, does not have the interface we would
like to have. Instead it requires the <code>wasm-bindgen</code> tool to postprocess the
file, generating a <code>foo.js</code> and <code>foo_bg.wasm</code> file. The <code>foo.js</code> file is the
desired interface expressed in JS (classes, types, strings, etc) and the
<code>foo_bg.wasm</code> module is simply used as an implementation detail (it was
lightly modified from the original <code>foo.wasm</code> file).</p>
<p>As more features are stabilized in WebAssembly over time (like host bindings)
the JS file is expected to get smaller and smaller. It's unlikely to ever
disappear, but <code>wasm-bindgen</code> is designed to follow the WebAssembly spec and
proposals closely to optimize JS/Rust as much as possible.</p>
<a class="header" href="#foundation-2-unintrusive-in-rust" id="foundation-2-unintrusive-in-rust"><h2>Foundation #2: Unintrusive in Rust</h2></a>
<p>On the more Rust-y side of things the <code>wasm-bindgen</code> crate is designed to
ideally have as minimal impact on a Rust crate as possible. Ideally a few
<code>#[wasm_bindgen]</code> attributes are annotated in key locations and otherwise you're
off to the races. The attribute strives to both not invent new syntax and work
with existing idioms today.</p>
<p>For example a library might exposed a function in normal Rust that looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greet(name: &amp;str) -&gt; String {
    // ...
}
#}</code></pre></pre>
<p>And with <code>#[wasm_bindgen]</code> all you need to do in exporting it to JS is:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn greet(name: &amp;str) -&gt; String {
    // ...
}
#}</code></pre></pre>
<p>Additionally the design here with minimal intervention in Rust should allow us
to easily take advantage of the upcoming <a href="https://github.com/WebAssembly/host-bindings">host bindings</a> proposal. Ideally
you'd simply upgrade <code>wasm-bindgen</code>-the-crate as well as your toolchain and
you're immediately getting raw access to host bindings! (this is still a bit of
a ways off though...)</p>
<a class="header" href="#polyfill-for-js-objects-in-wasm" id="polyfill-for-js-objects-in-wasm"><h1>Polyfill for &quot;JS objects in wasm&quot;</h1></a>
<p>One of the main goals of <code>wasm-bindgen</code> is to allow working with and passing
around JS objects in wasm, but that's not allowed today! While indeed true,
that's where the polyfill comes in.</p>
<p>The question here is how we shoehorn JS objects into a <code>u32</code> for wasm to use.
The current strategy for this approach is to maintain two module-local variables
in the generated <code>foo.js</code> file: a stack and a heap.</p>
<a class="header" href="#temporary-js-objects-on-the-stack" id="temporary-js-objects-on-the-stack"><h3>Temporary JS objects on the stack</h3></a>
<p>The stack in <code>foo.js</code> is, well, a stack. JS objects are pushed on the top of the
stack, and their index in the stack is the identifier that's passed to wasm. JS
objects are then only removed from the top of the stack as well. This data
structure is mainly useful for efficiently passing a JS object into wasm without
a sort of &quot;heap allocation&quot;. The downside of this, however, is that it only
works for when wasm doesn't hold onto a JS object (aka it only gets a
&quot;reference&quot; in Rust parlance).</p>
<p>Let's take a look at an example.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// foo.rs
#[wasm_bindgen]
pub fn foo(a: &amp;JsValue) {
    // ...
}
#}</code></pre></pre>
<p>Here we're using the special <code>JsValue</code> type from the <code>wasm-bindgen</code> library
itself. Our exported function, <code>foo</code>, takes a <em>reference</em> to an object. This
notably means that it can't persist the object past the lifetime of this
function call.</p>
<p>Now what we actually want to generate is a JS module that looks like (in
Typescript parlance)</p>
<pre><code class="language-ts">// foo.d.ts
export function foo(a: any);
</code></pre>
<p>and what we actually generate looks something like:</p>
<pre><code class="language-js">// foo.js
import * as wasm from './foo_bg';

const stack = [];

function addBorrowedObject(obj) {
  stack.push(obj);
  return stack.length - 1;
}

export function foo(arg0) {
  const idx0 = addBorrowedObject(arg0);
  try {
    wasm.foo(idx0);
  } finally {
    stack.pop();
  }
}
</code></pre>
<p>Here we can see a few notable points of action:</p>
<ul>
<li>The wasm file was renamed to <code>foo_bg.wasm</code>, and we can see how the JS module
generated here is importing from the wasm file.</li>
<li>Next we can see our <code>stack</code> module variable which is used to push/pop items
from the stack.</li>
<li>Our exported function <code>foo</code>, takes an arbitrary argument, <code>arg0</code>, which is
converted to an index with the <code>addBorrowedObject</code> object function. The index
is then passed to wasm so wasm can operate with it.</li>
<li>Finally, we have a <code>finally</code> which frees the stack slot as it's no longer
used, issuing a <code>pop</code> for what was pushed at the start of the function.</li>
</ul>
<p>It's also helpful to dig into the Rust side of things to see what's going on
there! Let's take a look at the code that <code>#[wasm_bindgen]</code> generates in Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// what the user wrote
pub fn foo(a: &amp;JsValue) {
    // ...
}

#[export_name = &quot;foo&quot;]
pub extern fn __wasm_bindgen_generated_foo(arg0: u32) {
    let arg0 = unsafe {
        ManuallyDrop::new(JsValue::__from_idx(arg0))
    };
    let arg0 = &amp;*arg0;
    foo(arg0);
}
#}</code></pre></pre>
<p>And as with the JS, the notable points here are:</p>
<ul>
<li>The original function, <code>foo</code>, is unmodified in the output</li>
<li>A generated function here (with a unique name) is the one that's actually
exported from the wasm module</li>
<li>Our generated function takes an integer argument (our index) and then wraps it
in a <code>JsValue</code>. There's some trickery here that's not worth going into just
yet, but we'll see in a bit what's happening under the hood.</li>
</ul>
<a class="header" href="#long-lived-js-objects-in-a-slab" id="long-lived-js-objects-in-a-slab"><h3>Long-lived JS objects in a slab</h3></a>
<p>The above strategy is useful when JS objects are only temporarily used in Rust,
for example only during one function call. Sometimes, though, objects may have a
dynamic lifetime or otherwise need to be stored on Rust's heap. To cope with
this there's a second half of management of JS objects, a slab.</p>
<p>JS Objects passed to wasm that are not references are assumed to have a dynamic
lifetime inside of the wasm module. As a result the strict push/pop of the stack
won't work and we need more permanent storage for the JS objects. To cope with
this we build our own &quot;slab allocator&quot; of sorts.</p>
<p>A picture (or code) is worth a thousand words so let's show what happens with an
example.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// foo.rs
#[wasm_bindgen]
pub fn foo(a: JsValue) {
    // ...
}
#}</code></pre></pre>
<p>Note that the <code>&amp;</code> is missing in front of the <code>JsValue</code> we had before, and in
Rust parlance this means it's taking ownership of the JS value. The exported ES
module interface is the same as before, but the ownership mechanics are slightly
different. Let's see the generated JS's slab in action:</p>
<pre><code class="language-js">import * as wasm from './foo_bg'; // imports from wasm file

const slab = [];
let slab_next = 0;

function addHeapObject(obj) {
  if (slab_next === slab.length)
    slab.push(slab.length + 1);
  const idx = slab_next;
  const next = slab[idx];
  slab_next = next;
  slab[idx] = { obj, cnt: 1 };
  return idx;
}

export function foo(arg0) {
  const idx0 = addHeapObject(arg0);
  wasm.foo(idx0);
}

export function __wbindgen_object_drop_ref(idx) {
  let obj = slab[idx];
  obj.cnt -= 1;
  if (obj.cnt &gt; 0)
    return;
  // If we hit 0 then free up our space in the slab
  slab[idx] = slab_next;
  slab_next = idx;
}
</code></pre>
<p>Unlike before we're now calling <code>addHeapObject</code> on the argument to <code>foo</code> rather
than <code>addBorrowedObject</code>. This function will use <code>slab</code> and <code>slab_next</code> as a
slab allocator to acquire a slot to store the object, placing a structure there
once it's found.</p>
<p>Note here that a reference count is used in addition to storing the object.
That's so we can create multiple references to the JS object in Rust without
using <code>Rc</code>, but it's overall not too important to worry about here.</p>
<p>Another curious aspect of this generated module is the
<code>__wbindgen_object_drop_ref</code> function. This is one that's actually imported from
wasm rather than used in this module! This function is used to signal the end of
the lifetime of a <code>JsValue</code> in Rust, or in other words when it goes out of
scope. Otherwise though this function is largely just a general &quot;slab free&quot;
implementation.</p>
<p>And finally, let's take a look at the Rust generated again too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// what the user wrote
pub fn foo(a: JsValue) {
    // ...
}

#[export_name = &quot;foo&quot;]
pub extern fn __wasm_bindgen_generated_foo(arg0: u32) {
    let arg0 = unsafe {
        JsValue::__from_idx(arg0)
    };
    foo(arg0);
}
#}</code></pre></pre>
<p>Ah that looks much more familiar! Not much interesting is happening here, so
let's move on to...</p>
<a class="header" href="#anatomy-of-jsvalue" id="anatomy-of-jsvalue"><h3>Anatomy of <code>JsValue</code></h3></a>
<p>Currently the <code>JsValue</code> struct is actually quite simple in Rust, it's:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct JsValue {
    idx: u32,
}

// &quot;private&quot; constructors

impl Drop for JsValue {
    fn drop(&amp;mut self) {
        unsafe {
            __wbindgen_object_drop_ref(self.idx);
        }
    }
}
#}</code></pre></pre>
<p>Or in other words it's a newtype wrapper around a <code>u32</code>, the index that we're
passed from wasm. The destructor here is where the <code>__wbindgen_object_drop_ref</code>
function is called to relinquish our reference count of the JS object, freeing
up our slot in the <code>slab</code> that we saw above.</p>
<p>If you'll recall as well, when we took <code>&amp;JsValue</code> above we generated a wrapper
of <code>ManuallyDrop</code> around the local binding, and that's because we wanted to
avoid invoking this destructor when the object comes from the stack.</p>
<a class="header" href="#indexing-both-a-slab-and-the-stack" id="indexing-both-a-slab-and-the-stack"><h3>Indexing both a slab and the stack</h3></a>
<p>You might be thinking at this point that this system may not work! There's
indexes into both the slab and the stack mixed up, but how do we differentiate?
It turns out that the examples above have been simplified a bit, but otherwise
the lowest bit is currently used as an indicator of whether you're a slab or a
stack index.</p>
<a class="header" href="#exporting-a-function-to-js" id="exporting-a-function-to-js"><h1>Exporting a function to JS</h1></a>
<p>Alright now that we've got a good grasp on JS objects and how they're working,
let's take a look at another feature of <code>wasm-bindgen</code>: exporting functionality
with types that are richer than just numbers.</p>
<p>The basic idea around exporting functionality with more flavorful types is that
the wasm exports won't actually be called directly. Instead the generated
<code>foo.js</code> module will have shims for all exported functions in the wasm module.</p>
<p>The most interesting conversion here happens with strings so let's take a look
at that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn greet(a: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, a)
}
#}</code></pre></pre>
<p>Here we'd like to define an ES module that looks like</p>
<pre><code class="language-ts">// foo.d.ts
export function greet(a: string): string;
</code></pre>
<p>To see what's going on, let's take a look at the generated shim</p>
<pre><code class="language-js">import * as wasm from './foo_bg';

function passStringToWasm(arg) {
  const buf = new TextEncoder('utf-8').encode(arg);
  const len = buf.length;
  const ptr = wasm.__wbindgen_malloc(len);
  let array = new Uint8Array(wasm.memory.buffer);
  array.set(buf, ptr);
  return [ptr, len];
}

function getStringFromWasm(ptr, len) {
  const mem = new Uint8Array(wasm.memory.buffer);
  const slice = mem.slice(ptr, ptr + len);
  const ret = new TextDecoder('utf-8').decode(slice);
  return ret;
}

export function greet(arg0) {
  const [ptr0, len0] = passStringToWasm(arg0);
  try {
    const ret = wasm.greet(ptr0, len0);
    const ptr = wasm.__wbindgen_boxed_str_ptr(ret);
    const len = wasm.__wbindgen_boxed_str_len(ret);
    const realRet = getStringFromWasm(ptr, len);
    wasm.__wbindgen_boxed_str_free(ret);
    return realRet;
  } finally {
    wasm.__wbindgen_free(ptr0, len0);
  }
}
</code></pre>
<p>Phew, that's quite a lot! We can sort of see though if we look closely what's
happening:</p>
<ul>
<li>
<p>Strings are passed to wasm via two arguments, a pointer and a length. Right
now we have to copy the string onto the wasm heap which means we'll be using
<code>TextEncoder</code> to actually do the encoding. Once this is done we use an
internal function in <code>wasm-bindgen</code> to allocate space for the string to go,
and then we'll pass that ptr/length to wasm later on.</p>
</li>
<li>
<p>Returning strings from wasm is a little tricky as we need to return a ptr/len
pair, but wasm currently only supports one return value (multiple return values
<a href="https://github.com/WebAssembly/design/issues/1146">is being standardized</a>).
To work around this in the meantime, we're actually returning a pointer to a
ptr/len pair, and then using functions to access the various fields.</p>
</li>
<li>
<p>Some cleanup ends up happening in wasm. The <code>__wbindgen_boxed_str_free</code>
function is used to free the return value of <code>greet</code> after it's been decoded
onto the JS heap (using <code>TextDecoder</code>). The <code>__wbindgen_free</code> is then used to
free the space we allocated to pass the string argument once the function call
is done.</p>
</li>
</ul>
<p>Next let's take a look at the Rust side of things as well. Here we'll be looking
at a mostly abbreviated and/or &quot;simplified&quot; in the sense of this is what it
compiles down to:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub extern fn greet(a: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, a)
}

#[export_name = &quot;greet&quot;]
pub extern fn __wasm_bindgen_generated_greet(
    arg0_ptr: *const u8,
    arg0_len: usize,
) -&gt; *mut String {
    let arg0 = unsafe {
        let slice = ::std::slice::from_raw_parts(arg0_ptr, arg0_len);
        ::std::str::from_utf8_unchecked(slice)
    };
    let _ret = greet(arg0);
    Box::into_raw(Box::new(_ret))
}
#}</code></pre></pre>
<p>Here we can see again that our <code>greet</code> function is unmodified and has a wrapper
to call it. This wrapper will take the ptr/len argument and convert it to a
string slice, while the return value is boxed up into just a pointer and is
then returned up to was for reading via the <code>__wbindgen_boxed_str_*</code> functions.</p>
<p>So in general exporting a function involves a shim both in JS and in Rust with
each side translating to or from wasm arguments to the native types of each
language. The <code>wasm-bindgen</code> tool manages hooking up all these shims while the
<code>#[wasm_bindgen]</code> macro takes care of the Rust shim as well.</p>
<p>Most arguments have a relatively clear way to convert them, bit if you've got
any questions just let me know!</p>
<a class="header" href="#exporting-a-struct-to-js" id="exporting-a-struct-to-js"><h1>Exporting a struct to JS</h1></a>
<p>So far we've covered JS objects, importing functions, and exporting functions.
This has given us quite a rich base to build on so far, and that's great! We
sometimes, though, want to go even further and define a JS <code>class</code> in Rust. Or
in other words, we want to expose an object with methods from Rust to JS rather
than just importing/exporting free functions.</p>
<p>The <code>#[wasm_bindgen]</code> attribute can annotate both a <code>struct</code> and <code>impl</code> blocks
to allow:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Foo {
    internal: i32,
}

#[wasm_bindgen]
impl Foo {
    pub fn new(val: i32) -&gt; Foo {
        Foo { internal: val }
    }

    pub fn get(&amp;self) -&gt; i32 {
        self.internal
    }

    pub fn set(&amp;mut self, val: i32) {
        self.internal = val;
    }
}
#}</code></pre></pre>
<p>This is a typical Rust <code>struct</code> definition for a type with a constructor and a
few methods. Annotating the struct with <code>#[wasm_bindgen]</code> means that we'll
generate necessary trait impls to convert this type to/from the JS boundary. The
annotated <code>impl</code> block here means that the functions inside will also be made
available to JS through generated shims. If we take a look at the generated JS
code for this we'll see:</p>
<pre><code class="language-js">import * as wasm from './js_hello_world_bg';

export class Foo {
    static __construct(ptr) {
        return new Foo(ptr);
    }

    constructor(ptr) {
        this.ptr = ptr;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;
        wasm.__wbg_foo_free(ptr);
    }

    static new(arg0) {
        const ret = wasm.foo_new(arg0);
        return Foo.__construct(ret)
    }

    get() {
        const ret = wasm.foo_get(this.ptr);
        return ret;
    }

    set(arg0) {
        const ret = wasm.foo_set(this.ptr, arg0);
        return ret;
    }
}
</code></pre>
<p>That's actually not much! We can see here though how we've translated from Rust
to JS:</p>
<ul>
<li>Associated functions in Rust (those without <code>self</code>) turn into <code>static</code>
functions in JS.</li>
<li>Methods in Rust turn into methods in wasm.</li>
<li>Manual memory management is exposed in JS as well. The <code>free</code> function is
required to be invoked to deallocate resources on the Rust side of things.</li>
</ul>
<p>To be able to use <code>new Foo()</code>, you'd need to annotate <code>new</code> as <code>#[wasm_bindgen(constructor)]</code>.</p>
<p>One important aspect to note here, though, is that once <code>free</code> is called the JS
object is &quot;neutered&quot; in that its internal pointer is nulled out. This means that
future usage of this object should trigger a panic in Rust.</p>
<p>The real trickery with these bindings ends up happening in Rust, however, so
let's take a look at that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// original input to `#[wasm_bindgen]` omitted ...

#[export_name = &quot;foo_new&quot;]
pub extern fn __wasm_bindgen_generated_Foo_new(arg0: i32) -&gt; u32
    let ret = Foo::new(arg0);
    Box::into_raw(Box::new(WasmRefCell::new(ret))) as u32
}

#[export_name = &quot;foo_get&quot;]
pub extern fn __wasm_bindgen_generated_Foo_get(me: u32) -&gt; i32 {
    let me = me as *mut WasmRefCell&lt;Foo&gt;;
    wasm_bindgen::__rt::assert_not_null(me);
    let me = unsafe { &amp;*me };
    return me.borrow().get();
}

#[export_name = &quot;foo_set&quot;]
pub extern fn __wasm_bindgen_generated_Foo_set(me: u32, arg1: i32) {
    let me = me as *mut WasmRefCell&lt;Foo&gt;;
    ::wasm_bindgen::__rt::assert_not_null(me);
    let me = unsafe { &amp;*me };
    me.borrow_mut().set(arg1);
}

#[no_mangle]
pub unsafe extern fn __wbindgen_foo_free(me: u32) {
    let me = me as *mut WasmRefCell&lt;Foo&gt;;
    wasm_bindgen::__rt::assert_not_null(me);
    (*me).borrow_mut(); // ensure no active borrows
    drop(Box::from_raw(me));
}
#}</code></pre></pre>
<p>As with before this is cleaned up from the actual output but it's the same idea
as to what's going on! Here we can see a shim for each function as well as a
shim for deallocating an instance of <code>Foo</code>. Recall that the only valid wasm
types today are numbers, so we're required to shoehorn all of <code>Foo</code> into a
<code>u32</code>, which is currently done via <code>Box</code> (like <code>std::unique_ptr</code> in C++).
Note, though, that there's an extra layer here, <code>WasmRefCell</code>. This type is the
same as <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> and can be mostly glossed over.</p>
<p>The purpose for this type, if you're interested though, is to uphold Rust's
guarantees about aliasing in a world where aliasing is rampant (JS).
Specifically the <code>&amp;Foo</code> type means that there can be as much aliasing as you'd
like, but crucially <code>&amp;mut Foo</code> means that it is the sole pointer to the data
(no other <code>&amp;Foo</code> to the same instance exists). The <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> type in libstd
is a way of dynamically enforcing this at runtime (as opposed to compile time
where it usually happens). Baking in <code>WasmRefCell</code> is the same idea here,
adding runtime checks for aliasing which are typically happening at compile
time. This is currently a Rust-specific feature which isn't actually in the
<code>wasm-bindgen</code> tool itself, it's just in the Rust-generated code (aka the
<code>#[wasm_bindgen]</code> attribute).</p>
<a class="header" href="#importing-a-function-from-js" id="importing-a-function-from-js"><h1>Importing a function from JS</h1></a>
<p>Now that we've exported some rich functionality to JS it's also time to import
some! The goal here is to basically implement JS <code>import</code> statements in Rust,
with fancy types and all.</p>
<p>First up, let's say we invert the function above and instead want to generate
greetings in JS but call it from Rust. We might have, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(module = &quot;./greet&quot;)]
extern {
    fn greet(a: &amp;str) -&gt; String;
}

fn other_code() {
    let greeting = greet(&quot;foo&quot;);
    // ...
}
#}</code></pre></pre>
<p>The basic idea of imports is the same as exports in that we'll have shims in
both JS and Rust doing the necessary translation. Let's first see the JS shim in
action:</p>
<pre><code class="language-js">import * as wasm from './foo_bg';

import { greet } from './greet';

// ...

export function __wbg_f_greet(ptr0, len0, wasmretptr) {
  const [retptr, retlen] = passStringToWasm(greet(getStringFromWasm(ptr0, len0)));
  (new Uint32Array(wasm.memory.buffer))[wasmretptr / 4] = retlen;
  return retptr;
}
</code></pre>
<p>The <code>getStringFromWasm</code> and <code>passStringToWasm</code> are the same as we saw before,
and like with <code>__wbindgen_object_drop_ref</code> far above we've got this weird export
from our module now! The <code>__wbg_f_greet</code> function is what's generated by
<code>wasm-bindgen</code> to actually get imported in the <code>foo.wasm</code> module.</p>
<p>The generated <code>foo.js</code> we see imports from the <code>./greet</code> module with the <code>greet</code>
name (was the function import in Rust said) and then the <code>__wbg_f_greet</code>
function is shimming that import.</p>
<p>There's some tricky ABI business going on here so let's take a look at the
generated Rust as well. Like before this is simplified from what's actually
generated.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern fn greet(a: &amp;str) -&gt; String {
    extern {
        fn __wbg_f_greet(a_ptr: *const u8, a_len: usize, ret_len: *mut usize) -&gt; *mut u8;
    }
    unsafe {
        let a_ptr = a.as_ptr();
        let a_len = a.len();
        let mut __ret_strlen = 0;
        let mut __ret_strlen_ptr = &amp;mut __ret_strlen as *mut usize;
        let _ret = __wbg_f_greet(a_ptr, a_len, __ret_strlen_ptr);
        String::from_utf8_unchecked(
            Vec::from_raw_parts(_ret, __ret_strlen, __ret_strlen)
        )
    }
}
#}</code></pre></pre>
<p>Here we can see that the <code>greet</code> function was generated but it's largely just a
shim around the <code>__wbg_f_greet</code> function that we're calling. The ptr/len pair
for the argument is passed as two arguments and for the return value we're
receiving one value (the length) indirectly while directly receiving the
returned pointer.</p>
<a class="header" href="#importing-a-class-from-js" id="importing-a-class-from-js"><h1>Importing a class from JS</h1></a>
<p>Just like with functions after we've started exporting we'll also want to
import! Now that we've exported a <code>class</code> to JS we'll want to also be able to
import classes in Rust as well to invoke methods and such. Since JS classes are
in general just JS objects the bindings here will look pretty similar to the JS
object bindings describe above.</p>
<p>As usual though, let's dive into an example!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(module = &quot;./bar&quot;)]
extern {
    type Bar;

    #[wasm_bindgen(constructor)]
    fn new(arg: i32) -&gt; Bar;

    #[wasm_bindgen(js_namespace = Bar)]
    fn another_function() -&gt; i32;

    #[wasm_bindgen(method)]
    fn get(this: &amp;Bar) -&gt; i32;

    #[wasm_bindgen(method)]
    fn set(this: &amp;Bar, val: i32);

    #[wasm_bindgen(method, getter)]
    fn property(this: &amp;Bar) -&gt; i32;

    #[wasm_bindgen(method, setter)]
    fn set_property(this: &amp;Bar, val: i32);
}

fn run() {
    let bar = Bar::new(Bar::another_function());
    let x = bar.get();
    bar.set(x + 3);

    bar.set_property(bar.property() + 6);
}
#}</code></pre></pre>
<p>Unlike our previous imports, this one's a bit more chatty! Remember that one of
the goals of <code>wasm-bindgen</code> is to use native Rust syntax wherever possible, so
this is mostly intended to use the <code>#[wasm_bindgen]</code> attribute to interpret
what's written down in Rust. Now there's a few attribute annotations here, so
let's go through one-by-one:</p>
<ul>
<li><code>#[wasm_bindgen(module = &quot;./bar&quot;)]</code> - seen before with imports this is declare
where all the subsequent functionality is imported form. For example the <code>Bar</code>
type is going to be imported from the <code>./bar</code> module.</li>
<li><code>type Bar</code> - this is a declaration of JS class as a new type in Rust. This
means that a new type <code>Bar</code> is generated which is &quot;opaque&quot; but is represented
as internally containing a <code>JsValue</code>. We'll see more on this later.</li>
<li><code>#[wasm_bindgen(constructor)]</code> - this indicates that the binding's name isn't
actually used in JS but rather translates to <code>new Bar()</code>. The return value of
this function must be a bare type, like <code>Bar</code>.</li>
<li><code>#[wasm_bindgen(js_namespace = Bar)]</code> - this attribute indicates that the
function declaration is namespaced through the <code>Bar</code> class in JS.</li>
<li><code>#[wasm_bindgen(static_method_of = SomeJsClass)]</code> - this attribute is similar
to <code>js_namespace</code>, but instead of producing a free function, produces a static
method of <code>SomeJsClass</code>.</li>
<li><code>#[wasm_bindgen(method)]</code> - and finally, this attribute indicates that a
method call is going to happen. The first argument must be a JS struct, like
<code>Bar</code>, and the call in JS looks like <code>Bar.prototype.set.call(...)</code>.</li>
</ul>
<p>With all that in mind, let's take a look at the JS generated.</p>
<pre><code class="language-js">import * as wasm from './foo_bg';

import { Bar } from './bar';

// other support functions omitted...

export function __wbg_s_Bar_new() {
  return addHeapObject(new Bar());
}

const another_function_shim = Bar.another_function;
export function __wbg_s_Bar_another_function() {
  return another_function_shim();
}

const get_shim = Bar.prototype.get;
export function __wbg_s_Bar_get(ptr) {
  return shim.call(getObject(ptr));
}

const set_shim = Bar.prototype.set;
export function __wbg_s_Bar_set(ptr, arg0) {
  set_shim.call(getObject(ptr), arg0)
}

const property_shim = Object.getOwnPropertyDescriptor(Bar.prototype, 'property').get;
export function __wbg_s_Bar_property(ptr) {
  return property_shim.call(getObject(ptr));
}

const set_property_shim = Object.getOwnPropertyDescriptor(Bar.prototype, 'property').set;
export function __wbg_s_Bar_set_property(ptr, arg0) {
  set_property_shim.call(getObject(ptr), arg0)
}
</code></pre>
<p>Like when importing functions from JS we can see a bunch of shims are generated
for all the relevant functions. The <code>new</code> static function has the
<code>#[wasm_bindgen(constructor)]</code> attribute which means that instead of any
particular method it should actually invoke the <code>new</code> constructor instead (as
we see here). The static function <code>another_function</code>, however, is dispatched as
<code>Bar.another_function</code>.</p>
<p>The <code>get</code> and <code>set</code> functions are methods so they go through <code>Bar.prototype</code>,
and otherwise their first argument is implicitly the JS object itself which is
loaded through <code>getObject</code> like we saw earlier.</p>
<p>Some real meat starts to show up though on the Rust side of things, so let's
take a look:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Bar {
    obj: JsValue,
}

impl Bar {
    fn new() -&gt; Bar {
        extern {
            fn __wbg_s_Bar_new() -&gt; u32;
        }
        unsafe {
            let ret = __wbg_s_Bar_new();
            Bar { obj: JsValue::__from_idx(ret) }
        }
    }

    fn another_function() -&gt; i32 {
        extern {
            fn __wbg_s_Bar_another_function() -&gt; i32;
        }
        unsafe {
            __wbg_s_Bar_another_function()
        }
    }

    fn get(&amp;self) -&gt; i32 {
        extern {
            fn __wbg_s_Bar_get(ptr: u32) -&gt; i32;
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            let ret = __wbg_s_Bar_get(ptr);
            return ret
        }
    }

    fn set(&amp;self, val: i32) {
        extern {
            fn __wbg_s_Bar_set(ptr: u32, val: i32);
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            __wbg_s_Bar_set(ptr, val);
        }
    }

    fn property(&amp;self) -&gt; i32 {
        extern {
            fn __wbg_s_Bar_property(ptr: u32) -&gt; i32;
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            let ret = __wbg_s_Bar_property(ptr);
            return ret
        }
    }

    fn set_property(&amp;self, val: i32) {
        extern {
            fn __wbg_s_Bar_set_property(ptr: u32, val: i32);
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            __wbg_s_Bar_set_property(ptr, val);
        }
    }
}

impl WasmBoundary for Bar {
    // ...
}

impl ToRefWasmBoundary for Bar {
    // ...
}
#}</code></pre></pre>
<p>In Rust we're seeing that a new type, <code>Bar</code>, is generated for this import of a
class. The type <code>Bar</code> internally contains a <code>JsValue</code> as an instance of <code>Bar</code>
is meant to represent a JS object stored in our module's stack/slab. This then
works mostly the same way that we saw JS objects work in the beginning.</p>
<p>When calling <code>Bar::new</code> we'll get an index back which is wrapped up in <code>Bar</code>
(which is itself just a <code>u32</code> in memory when stripped down). Each function then
passes the index as the first argument and otherwise forwards everything along
in Rust.</p>
<a class="header" href="#rust-type-conversions" id="rust-type-conversions"><h1>Rust Type conversions</h1></a>
<p>Previously we've been seeing mostly abridged versions of type conversions when
values enter Rust. Here we'll go into some more depth about how this is
implemented. There are two categories of traits for converting values, traits
for converting values from Rust to JS and traits for the other way around.</p>
<a class="header" href="#from-rust-to-js" id="from-rust-to-js"><h2>From Rust to JS</h2></a>
<p>First up let's take a look at going from Rust to JS:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait IntoWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    fn into_abi(self, extra: &amp;mut Stack) -&gt; Self::Abi;
}
#}</code></pre></pre>
<p>And that's it! This is actually the only trait needed currently for translating
a Rust value to a JS one. There's a few points here:</p>
<ul>
<li>We'll get to <code>WasmDescribe</code> later in this section</li>
<li>The associated type <code>Abi</code> is what will actually be generated as an argument to
the wasm export. The bound <code>WasmAbi</code> is only implemented for types like <code>u32</code>
and <code>f64</code>, those which can be placed on the boundary and transmitted
losslessly.</li>
<li>And finally we have the <code>into_abi</code> function, returning the <code>Abi</code> associated
type which will be actually passed to JS. There's also this <code>Stack</code> parameter,
however. Not all Rust values can be communicated in 32 bits to the <code>Stack</code>
parameter allows transmitting more data, explained in a moment.</li>
</ul>
<p>This trait is implemented for all types that can be converted to JS and is
unconditionally used during codegen. For example you'll often see <code>IntoWasmAbi for Foo</code> but also <code>IntoWasmAbi for &amp;'a Foo</code>.</p>
<p>The <code>IntoWasmAbi</code> trait is used in two locations. First it's used to convert
return values of Rust exported functions to JS. Second it's used to convert the
Rust arguments of JS functions imported to Rust.</p>
<a class="header" href="#from-js-to-rust" id="from-js-to-rust"><h2>From JS to Rust</h2></a>
<p>Unfortunately the opposite direction from above, going from JS to Rust, is a bit
more complicated. Here we've got three traits:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait FromWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    unsafe fn from_abi(js: Self::Abi, extra: &amp;mut Stack) -&gt; Self;
}

pub trait RefFromWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    type Anchor: Deref&lt;Target=Self&gt;;
    unsafe fn ref_from_abi(js: Self::Abi, extra: &amp;mut Stack) -&gt; Self::Anchor;
}

pub trait RefMutFromWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    type Anchor: DerefMut&lt;Target=Self&gt;;
    unsafe fn ref_mut_from_abi(js: Self::Abi, extra: &amp;mut Stack) -&gt; Self::Anchor;
}
#}</code></pre></pre>
<p>The <code>FromWasmAbi</code> is relatively straightforward, basically the opposite of
<code>IntoWasmAbi</code>. It takes the ABI argument (typically the same as
<code>IntoWasmAbi::Abi</code>) and then the auxiliary stack to produce an instance of
<code>Self</code>. This trait is implemented primarily for types that <em>don't</em> have internal
lifetimes or are references.</p>
<p>The latter two traits here are mostly the same, and are intended for generating
references (both shared and mutable references). They look almost the same as
<code>FromWasmAbi</code> except that they return an <code>Anchor</code> type which implements a
<code>Deref</code> trait rather than <code>Self</code>.</p>
<p>The <code>Ref*</code> traits allow having arguments in functions that are references rather
than bare types, for example <code>&amp;str</code>, <code>&amp;JsValue</code>, or <code>&amp;[u8]</code>. The <code>Anchor</code> here
is required to ensure that the lifetimes don't persist beyond one function call
and remain anonymous.</p>
<p>The <code>From*</code> family of traits are used for converting the Rust arguments in Rust
exported functions to JS. They are also used for the return value in JS
functions imported into Rust.</p>
<a class="header" href="#global-stack" id="global-stack"><h2>Global stack</h2></a>
<p>Mentioned above not all Rust types will fit within 32 bits. While we can
communicate an <code>f64</code> we don't necessarily have the ability to use all the bits.
Types like <code>&amp;str</code> need to communicate two items, a pointer and a length (64
bits). Other types like <code>&amp;Closure&lt;Fn()&gt;</code> have even more information to
transmit.</p>
<p>As a result we need a method of communicating more data through the signatures
of functions. While we could add more arguments this is somewhat difficult to do
in the world of closures where code generation isn't quite as dynamic as a
procedural macro. Consequently a &quot;global stack&quot; is used to transmit extra
data for a function call.</p>
<p>The global stack is a fixed-sized static allocation in the wasm module. This
stack is temporary scratch space for any one function call from either JS to
Rust or Rust ot JS. Both Rust and the JS shim generated have pointers to this
global stack and will read/write information from it.</p>
<p>Using this scheme whenever we want to pass <code>&amp;str</code> from JS to Rust we can pass
the pointer as the actual ABI argument and the length is then placed in the next
spot on the global stack.</p>
<p>The <code>Stack</code> argument to the conversion traits above looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Stack {
    fn push(&amp;mut self, bits: u32);
    fn pop(&amp;mut self) -&gt; u32;
}
#}</code></pre></pre>
<p>A trait is used here to facilitate testing but typically the calls don't end up
being virtually dispatched at runtime.</p>
<a class="header" href="#communicating-types-to-wasm-bindgen" id="communicating-types-to-wasm-bindgen"><h1>Communicating types to <code>wasm-bindgen</code></h1></a>
<p>The last aspect to talk about when converting Rust/JS types amongst one another
is how this information is actually communicated. The <code>#[wasm_bindgen]</code> macro is
running over the syntactical (unresolved) structure of the Rust code and is then
responsible for generating information that <code>wasm-bindgen</code> the CLI tool later
reads.</p>
<p>To accomplish this a slightly unconventional approach is taken. Static
information about the structure of the Rust code is serialized via JSON
(currently) to a custom section of the wasm executable. Other information, like
what the types actually are, unfortunately isn't known until later in the
compiler due to things like associated type projections and typedefs. It also
turns out that we want to convey &quot;rich&quot; types like <code>FnMut(String, Foo, &amp;JsValue)</code> to the <code>wasm-bindgen</code> CLI, and handling all this is pretty tricky!</p>
<p>To solve this issue the <code>#[wasm_bindgen]</code> macro generates <strong>executable
functions</strong> which &quot;describe the type signature of an import or export&quot;. These
executable functions are what the <code>WasmDescribe</code> trait is all about:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait WasmDescribe {
    fn describe();
}
#}</code></pre></pre>
<p>While deceptively simple this trait is actually quite important. When you write,
an export like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
fn greet(a: &amp;str) {
    // ...
}
#}</code></pre></pre>
<p>In addition to the shims we talked about above which JS generates the macro
<em>also</em> generates something like:</p>
<pre><code>#[no_mangle]
pub extern fn __wbindgen_describe_greet() {
    &lt;Fn(&amp;str)&gt;::describe();
}
</code></pre>
<p>Or in other words it generates invocations of <code>describe</code> functions. In doing so
the <code>__wbindgen_describe_greet</code> shim is a programmatic description of the type
layouts of an import/export. These are then executed when <code>wasm-bindgen</code> runs!
These executions rely on an import called <code>__wbindgen_describe</code> which passes one
<code>u32</code> to the host, and when called multiple times gives a <code>Vec&lt;u32&gt;</code>
effectively. This <code>Vec&lt;u32&gt;</code> can then be reparsed into an <code>enum Descriptor</code>
which fully describes a type.</p>
<p>All in all this is a bit roundabout but shouldn't have any impact on the
generated code or runtime at all. All these descriptor functions are pruned from
the emitted wasm file.</p>
<a class="header" href="#js-sys" id="js-sys"><h1><code>js-sys</code></h1></a>
<p>The <a href="https://crates.io/crates/js-sys"><code>js-sys</code> crate</a> provides raw bindings to all the global APIs
guaranteed to exist in every JavaScript environment by the ECMAScript standard,
and its source lives at <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys"><code>wasm-bindgen/crates/js-sys</code></a>.  With the <code>js-sys</code>
crate, we can work with <code>Object</code>s, <code>Array</code>s, <code>Function</code>s, <code>Map</code>s, <code>Set</code>s,
etc... without writing the <code>#[wasm_bindgen]</code> imports by hand.</p>
<p>Documentation for this crate will eventually be available on <a href="https://docs.rs/js-sys">docs.rs</a>
but temporarily you can also check out the <a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/">master branch
documentation</a> for the crate.</p>
<p>For example, we can invoke JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a> callbacks and
time how long they take to execute with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now"><code>Date.now()</code></a>, and we
don't need to write any JS imports ourselves:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate js_sys;
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn timed(callback: &amp;js_sys::Function) -&gt; f64 {
    let then = js_sys::Date::now();
    callback.apply(JsValue::null(), &amp;js_sys::Array::new()).unwrap();
    let now = js_sys::Date::now();
    now - then
}
#}</code></pre></pre>
<p>The <code>js-sys</code> crate doesn't contain bindings to any Web APIs like
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll"><code>document.querySelectorAll</code></a>. These will be part of the
<a href="./web-sys.html"><code>web-sys</code></a> crate.</p>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>You can test the <code>js-sys</code> crate by running <code>cargo test --target wasm32-unknown-unknown</code> within the <code>crates/js-sys</code> directory in the
<code>wasm-bindgen</code> repository:</p>
<pre><code class="language-sh">cd wasm-bindgen/crates/js-sys
cargo test --target wasm32-unknown-unknown
</code></pre>
<p>These tests are largely executed in Node.js right now via the
<a href="../../wasm-bindgen-test/index.html"><code>wasm-bindgen-test</code> framework</a></p>
<a class="header" href="#adding-support-for-more-javascript-global-apis" id="adding-support-for-more-javascript-global-apis"><h1>Adding Support for More JavaScript Global APIs</h1></a>
<p>As of 2018-09-24 we've <a href="https://github.com/rustwasm/wasm-bindgen/issues/275">added all APIs</a> in the current ECMAScript
standard (yay!). To that end you'll hopefully not find a missing API, but if you
do please feel free to file an issue!</p>
<p>We currently add new APIs added to ECMAScript that are in <a href="https://tc39.github.io/process-document/">TC39 stage 4</a>
to this crate. If there's a new API in stage 4, feel free to file an issue as
well!</p>
<a class="header" href="#instructions-for-adding-an-api" id="instructions-for-adding-an-api"><h3>Instructions for adding an API</h3></a>
<ul>
<li>
<p>[ ] Find the <code>wasm-bindgen</code> issue for the API you'd like to add. If this
doesn't exist, feel free to open one! Afterwards be sure to comment on the
issue to avoid duplication of work.</p>
</li>
<li>
<p>[ ] Open the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN
page</a>
for the relevant JS API.</p>
</li>
<li>
<p>[ ] Open <code>crates/js-sys/src/lib.rs</code> in your editor; this is the file where we
are implementing the bindings.</p>
</li>
<li>
<p>[ ] Follow the instructions in the top of <code>crates/js-sys/src/lib.rs</code> about how
to add new bindings.</p>
</li>
<li>
<p>[ ] Add a test for the new binding to <code>crates/js-sys/tests/wasm/MyType.rs</code></p>
</li>
<li>
<p>[ ] Run the <a href="testing.html">JS global API bindings tests</a></p>
</li>
<li>
<p>[ ] Send a pull request!</p>
</li>
</ul>
<a class="header" href="#web-sys" id="web-sys"><h1><code>web-sys</code></h1></a>
<p>The <code>web-sys</code> crate provides raw bindings to all of the Web's APIs, and its
source lives at <code>wasm-bindgen/crates/web-sys</code>.</p>
<p>The <code>web-sys</code> crate is <strong>entirely</strong> mechanically generated inside <code>build.rs</code>
using <code>wasm-bindgen</code>'s WebIDL frontend and the WebIDL interface definitions for
Web APIs. This means that <code>web-sys</code> isn't always the most ergonomic crate to
use, but it's intended to provide verified and correct bindings to the web
platform, and then better interfaces can be iterated on crates.io!</p>
<a class="header" href="#web-sys-overview" id="web-sys-overview"><h1><code>web-sys</code> Overview</h1></a>
<p>The <code>web-sys</code> crate has this file and directory layout:</p>
<pre><code class="language-text">.
├── build.rs
├── Cargo.toml
├── README.md
├── src
│   └── lib.rs
└── webidls
    └── enabled
        └── ...
</code></pre>
<a class="header" href="#webidlsenabledwebidl" id="webidlsenabledwebidl"><h3><code>webidls/enabled/*.webidl</code></h3></a>
<p>These are the WebIDL interfaces that we will actually generate bindings for (or
at least bindings for <em>some</em> of the things defined in these files).</p>
<a class="header" href="#buildrs" id="buildrs"><h3><code>build.rs</code></h3></a>
<p>The <code>build.rs</code> invokes <code>wasm-bindgen</code>'s WebIDL frontend on all the WebIDL files
in <code>webidls/enabled</code>. It writes the resulting bindings into the cargo build's
out directory.</p>
<a class="header" href="#srclibrs-13" id="srclibrs-13"><h3><code>src/lib.rs</code></h3></a>
<p>The only thing <code>src/lib.rs</code> does is include the bindings generated at compile
time in <code>build.rs</code>. Here is the whole <code>src/lib.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! Raw API bindings for Web APIs
//!
//! This is a procedurally generated crate from browser WebIDL which provides a
//! binding to all APIs that browser provide on the web.
//!
//! This crate by default contains very little when compiled as almost all of
//! its exposed APIs are gated by Cargo features. The exhaustive list of
//! features can be found in `crates/web-sys/Cargo.toml`, but the rule of thumb
//! for `web-sys` is that each type has its own cargo feature (named after the
//! type). Using an API requires enabling the features for all types used in the
//! API, and APIs should mention in the documentation what features they
//! require.

#![doc(html_root_url = &quot;https://docs.rs/web-sys/0.2&quot;)]

extern crate wasm_bindgen;
extern crate js_sys;

use js_sys::Object;

#[cfg(feature = &quot;Window&quot;)]
pub fn window() -&gt; Option&lt;Window&gt; {
    use wasm_bindgen::JsCast;

    js_sys::global().dyn_into::&lt;Window&gt;().ok()
}

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/bindings.rs&quot;));

#}</code></pre></pre>
<a class="header" href="#cargo-features" id="cargo-features"><h3>Cargo features</h3></a>
<p>When compiled the crate is almost empty by default, which probably isn't what
you want! Due to the very large number of APIs, this crate uses features to
enable portions of its API to reduce compile times. The list of features in
<code>Cargo.toml</code> all correspond to types in the generated functions. Enabling a
feature enables that type. All methods should indicate what features need to be
activated to use the method.</p>
<a class="header" href="#testing-1" id="testing-1"><h1>Testing</h1></a>
<p>You can test the <code>web-sys</code> crate by running <code>cargo test</code> within the
<code>crates/web-sys</code> directory in the <code>wasm-bindgen</code> repository:</p>
<pre><code class="language-sh">cd wasm-bindgen/crates/web-sys
cargo test --target wasm32-unknown-unknown --all-features
</code></pre>
<p>The Wasm tests all run within a headless browser. See <a href="https://github.com/rustwasm/wasm-bindgen/blob/master/crates/test/README.md">the <code>wasm-bindgen-test</code>
crate's
<code>README.md</code></a>
for details and configuring which headless browser is used.</p>
<a class="header" href="#logging" id="logging"><h1>Logging</h1></a>
<p>The <code>wasm_bindgen_webidl</code> crate (used by <code>web-sys</code>'s <code>build.rs</code>) uses
<a href="https://crates.io/crates/env_logger"><code>env_logger</code></a> for logging, which can be enabled by setting the
<code>RUST_LOG=wasm_bindgen_webidl</code> environment variable while building the <code>web-sys</code>
crate.</p>
<p>Make sure to enable &quot;very verbose&quot; output during <code>cargo build</code> to see these logs
within <code>web-sys</code>'s build script output.</p>
<pre><code class="language-sh">cd crates/web-sys
RUST_LOG=wasm_bindgen_webidl cargo build -vv
</code></pre>
<p>If <code>wasm_bindgen_webidl</code> encounters WebIDL constructs that it doesn't know how
to translate into <code>wasm-bindgen</code> AST items, it will emit warn-level logs.</p>
<pre><code>WARN 2018-07-06T18:21:49Z: wasm_bindgen_webidl: Unsupported WebIDL interface: ...
</code></pre>
<a class="header" href="#supporting-more-web-apis-in-web-sys" id="supporting-more-web-apis-in-web-sys"><h1>Supporting More Web APIs in <code>web-sys</code></h1></a>
<ol>
<li>
<p><input type="checkbox"/> Ensure that the <code>.webidl</code> file describing the
interface exists somewhere within the <code>crates/web-sys/webidls/enabled</code>
directory.</p>
<p>First, check to see whether we have the WebIDL definition file for
your API:</p>
<pre><code class="language-sh">grep -rn MyWebApi crates/web-sys/webidls
</code></pre>
<ul>
<li>
<p>If your interface is defined in a <code>.webidl</code> file that is inside the
<code>crates/web-sys/webidls/enabled</code> directory, skip to step (3).</p>
</li>
<li>
<p>If your interface isn't defined in any file yet, find the WebIDL definition
in the relevant standard and add it as a new <code>.webidl</code> file in
<code>crates/web-sys/webidls/enabled</code>. Make sure that it is a standard Web API!
We don't want to add non-standard APIs to this crate.</p>
</li>
<li>
<p>If your interface is defined in a <code>.webidl</code> file within any of the
<code>crates/web-sys/webidls/unavailable_*</code> directories, you need to move it into
<code>crates/web-sys/webidls/enabled</code>, e.g.:</p>
<pre><code class="language-sh">cd crates/web-sys
git mv webidls/unavailable_enum_ident/MyWebApi.webidl webidls/enabled/MyWebApi.webidl
</code></pre>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Verify that the <code>web-sys</code> crate still builds and
that its tests still pass with the new <code>.webidl</code> file enabled:</p>
<pre><code class="language-sh">cd crates/web-sys
cargo build
cargo test
</code></pre>
</li>
<li>
<p><input type="checkbox"/> Verify that bindings are being generated for your new
API by generating the documentation and searching for the new API in it:</p>
<pre><code class="language-sh">cd crates/web-sys
cargo doc --open
# search for the new API in the opened docs
</code></pre>
<ul>
<li>
<p><input type="checkbox"/> If the new API is <strong>not</strong> showing up in the docs,
rebuild the <code>web-sys</code> crate <a href="logging.html">with logging enabled</a>
and look for warning messages that mention your new API. Figure out why
bindings weren't generated and then add support to <code>wasm_bindgen_webidl</code> for
whatever is needed to generate your API's bindings.</p>
<blockquote>
<p>You might find it helpful to view the generated rust bindings, to see if
they are what you would expect. The file will be located at
<code>target/wasm32-unknown-unknown/debug/build/web-sys-xxx/out/bindings.rs</code>,
where <code>xxx</code> is a combinations of numbers and letters that represents your
build. This file is pretty unintelligable until you run <code>rustfmt</code> on it, like
<code>rustfmt target/wasm32-unknown-unknown/debug/build/web-sys-xxx/out/bindings.rs</code>.</p>
</blockquote>
<blockquote>
<p>There are commented out lines in <code>web-sys/build.rs</code> that run rustfmt as part of
the build process, and this can be very helpful for debugging as any error
messages with inline code will display it in a readable format.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Add tests for as many of the features in the WebIDL file
as possible to <code>crates/web-sys/tests/all/</code>. See the
<a href="testing.html"><code>web-sys</code> testing documentation</a> for details.</p>
<blockquote>
<p><strong>Note</strong>: Start here at <strong>4</strong> if the WebIDL has already been added but doesn't have
full test coverage, then go back to <strong>3</strong> if you find any problems.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> If all entities in the WebIDL file have full test coverage,
mark the WebIDL script in the <code>README.md</code> file as complete by changing <code>[ ]</code> to <code>[x]</code>.</p>
</li>
<li>
<p><input type="checkbox"/> Send a pull request! 😊</p>
</li>
</ol>
<a class="header" href="#publishing-new-wasm-bindgen-releases" id="publishing-new-wasm-bindgen-releases"><h1>Publishing New <code>wasm-bindgen</code> Releases</h1></a>
<ol>
<li>
<p><input type="checkbox"/> Compile the <code>publish.rs</code> script:</p>
<pre><code>rustc publish.rs
</code></pre>
</li>
<li>
<p><input type="checkbox"/> Bump every crate's minor version:</p>
<pre><code># Make sure you are in the root of the wasm-bindgen repo!
./publish bump
</code></pre>
</li>
<li>
<p><input type="checkbox"/> Send a pull request for the version bump.</p>
</li>
<li>
<p><input type="checkbox"/> After the pull request's CI is green and it has been
merged, publish to cargo:</p>
<pre><code># Make sure you are in the root of the wasm-bindgen repo!
./publish publish
</code></pre>
</li>
</ol>
<a class="header" href="#team" id="team"><h1>Team</h1></a>
<p><code>wasm-bindgen</code> follows the <a href="https://github.com/rustwasm/team/blob/master/GOVERNANCE.md#repositories"><code>rustwasm</code> organization's governance described
here</a>:</p>
<ul>
<li>
<p>All pull requests (including those made by a team member) must be approved by
at least one other team member.</p>
</li>
<li>
<p>Larger, more nuanced decisions about design, architecture, breaking changes,
trade offs, etc are made by team consensus.</p>
</li>
</ul>
<a class="header" href="#members" id="members"><h2>Members</h2></a>
<style>
img {
    max-width: 117px;
    max-height: 117px;
}
</style>
<table><thead><tr><th align="center"> <a href="https://github.com/alexcrichton"><img src="https://github.com/alexcrichton.png?size=117" alt="" /></a> </th><th align="center"> <a href="https://github.com/fitzgen"><img src="https://github.com/fitzgen.png?size=117" alt="" /></a> </th><th align="center"> <a href="https://github.com/spastorino"><img src="https://github.com/spastorino.png?size=117" alt="" /></a> </th><th align="center"> <a href="https://github.com/ohanar"><img src="https://github.com/ohanar.png?size=117" alt="" /></a> </th><th> <a href="https://github.com/jonathan-s"><img src="https://github.com/jonathan-s.png?size=117" alt="" /></a> </th></tr></thead><tbody>
<tr><td align="center"> <a href="https://github.com/alexcrichton"><code>alexcrichton</code></a> </td><td align="center"> <a href="https://github.com/fitzgen"><code>fitzgen</code></a> </td><td align="center"> <a href="https://github.com/spastorino"><code>spastorino</code></a> </td><td align="center"> <a href="https://github.com/ohanar"><code>ohanar</code></a> </td><td> <a href="https://github.com/jonathan-s"><code>jonathan-s</code></a> </td></tr>
<tr><td align="center"> <a href="https://github.com/sendilkumarn"><img src="https://github.com/sendilkumarn.png?size=117" alt="" /></a> </td><td align="center"> <a href="https://github.com/belfz"><img src="https://github.com/belfz.png?size=117" alt="" /></a> </td><td align="center"> <a href="https://github.com/afdw"><img src="https://github.com/afdw.png?size=117" alt="" /></a> </td><td align="center"> </td><td> </td></tr>
<tr><td align="center"> <a href="https://github.com/sendilkumarn"><code>sendilkumarn</code></a> </td><td align="center"> <a href="https://github.com/belfz"><code>belfz</code></a> </td><td align="center"> <a href="https://github.com/afdw"><code>afdw</code></a> </td><td align="center"> </td><td> </td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
